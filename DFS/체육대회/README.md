# 체육대회

#DFS #백트래킹 #순열

# 문제 난이도 {하}

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| N (학생 수) | 1 ~ 10 | 매우 작음. O(N!) 또는 O(2^N) 가능 |
| M (종목 수) | 1 ~ N | 종목의 수도 학생 수 이하 |
| 시간 제한 | 통상 10초 | 파이썬 기준 2억 연산 충분히 가능 |
| 메모리 제한 | 통상 | 특이사항 없음 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=5 | N=10 | N=15 |
|--------|---------|----------|-----------|
| O(N!) | 120 ✅ | 3,628,800 ✅ | 1.3 x 10^12 ❌ |
| O(2^N) | 32 ✅ | 1,024 ✅ | 32,768 ✅ |

**이 문제의 경우**:
- N = 10 (최대) 이므로
- 순열 P(10, 10) = 10! ≈ 360만 연산.
- **결론**: **O(N!) (완전 탐색)** 알고리즘으로 충분히 통과 가능.

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 최적해(최대합) | 완전탐색 or DP |
| 순서가 중요한가 | 중요함 (종목별 배정) | 순열(Permutation) |
| 중복 선택 불가 | 한 학생은 한 종목만 | 방문 처리(Visited) 필요 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: [DFS / 백트래킹]

**선택 근거 (Why this algorithm?)**

1.  **문제 구조와의 적합성**
    - M개의 종목에 대해 N명의 학생 중 하나를 선택하여 매칭하는 문제입니다.
    - 각 단계(종목)마다 선택지(학생)를 고르고 다음 단계로 넘어가는 구조가 DFS에 적합합니다.

2.  **제약 조건 충족**
    - 최대 연산량은 10P10 (모든 종목에 학생 배정) = 약 360만 회.
    - 파이썬의 연산 속도로도 0.1초 내외로 해결 가능합니다.

3.  **핵심 인사이트**
    - "순서가 있는 뽑기"와 같습니다.
    - 첫 번째 종목에 누구를 보낼지 결정 -> 두 번째 종목 결정 -> ... (재귀적 구조)

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 헝가리안 알고리즘 | O(N^3) | 구현이 복잡하며, N이 작아 굳이 필요 없음 |
| 비트마스크 DP | O(M * 2^N) | 효율적이나, DFS로도 충분하여 직관적인 DFS 선택 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "최대 합", "대표 선출", "배정", "N이 10~12 이하"
- **문제 유형**: 순열 생성, 자원 할당 문제

---

## 2. 🧠 자연어 실행 흐름

1.  `dfs` 함수를 정의합니다. 인자는 `depth` (현재 배정하려는 종목 인덱스)와 `current_sum` (현재까지의 능력치 합)을 받습니다.
2.  **종료 조건**: `depth`가 종목의 개수(M)와 같다면, 모든 종목에 대표가 배정된 것입니다. 이때 `result`를 최댓값으로 갱신하고 리턴합니다.
3.  **탐색 수행**: 0번부터 N-1번 학생까지 순회합니다.
    - 만약 해당 학생이 아직 대표로 선발되지 않았다면 (`visited[i] == False`):
        - 방문 체크 (`visited[i] = True`)
        - `dfs(depth + 1, current_sum + ability[i][depth])` 호출
        - 방문 체크 해제 (`visited[i] = False`) (백트래킹)
4.  메인 함수에서 `visited` 배열을 초기화하고 `dfs(0, 0)`을 시작합니다.
5.  최종적으로 갱신된 최댓값을 반환합니다.

---

## 3. 💻 Code Implementation

(언어: Python)
```python
answer = 0

def solution(ability):
    global answer
    student_count = len(ability)      # 학생 수 (행)
    sport_count = len(ability[0])     # 종목 수 (열)
    visited = [False] * student_count # 학생 방문 여부 체크

    def dfs(depth, current_sum):
        global answer
        
        # 기저 조건: 모든 종목에 대해 대표를 뽑았을 때
        if depth == sport_count:
            answer = max(answer, current_sum)
            return

        # 모든 학생을 확인하며 해당 종목(depth)에 배정 시도
        for i in range(student_count):
            if not visited[i]:
                visited[i] = True
                # depth번째 종목에 i번 학생 배정
                dfs(depth + 1, current_sum + ability[i][depth])
                visited[i] = False # 백트래킹

    dfs(0, 0)
    return answer
```

**복잡도 분석**
- 시간: O(N P M) (N명 중 M명을 순서대로 뽑는 경우의 수). 최대 10! ≈ 3.6 x 10^6
- 공간: O(N) (재귀 호출 스택 및 visited 배열)

# 평가

## 개선할 점
- **`nonlocal` 키워드 활용**: `max_ability`를 리스트(`[0]`)로 감싸서 참조하는 방식은 Python 2 시절의 기법이거나 우회 방법입니다. Python 3에서는 `nonlocal` 키워드를 사용하여 내부 함수에서 바깥 스코프의 변수를 더 깔끔하게 수정할 수 있습니다.
- **순열 라이브러리 활용**: N과 M이 작으므로 직접 DFS를 구현하는 대신 `itertools.permutations`를 사용하면 코드를 훨씬 간결하게(3~4줄) 작성할 수 있습니다. 코딩 테스트에서는 구현 속도도 중요하므로 고려해볼 만한 대안입니다.
- **Branch and Bound (가지치기)**: 현재는 모든 경우를 다 탐색하지만, 만약 남은 종목들의 최대 능력을 다 더해도 현재의 `max_ability`를 넘지 못한다면 탐색을 중단하는 로직을 추가하여 성능을 최적화할 수 있습니다.

## 잘한 점
- **명확한 변수 명명**: `students`, `sports`, `visited`, `depth` 등 변수명이 직관적이어서 코드의 의도를 파악하기 쉽습니다.
- **정확한 백트래킹 구현**: `visited[i] = True` 후 재귀 호출하고 다시 `False`로 되돌리는 백트래킹의 정석적인 패턴을 잘 구현했습니다.
- **함수 중첩 활용**: `dfs` 함수를 `solution` 내부에 정의하여 `ability`, `visited` 등의 변수에 쉽게 접근하도록 설계한 구조가 좋습니다.

## 다른 응용 방안
- **N-Queen 문제**: 1차원 배열이나 규칙을 통해 서로 공격하지 않는 퀸의 배치를 찾는 문제에서도 유사한 백트래킹 구조가 사용됩니다.
- **TSP (외판원 순회)**: 모든 도시를 방문하고 돌아오는 최소 비용 문제도 N이 작을 경우 유사한 DFS로 해결 가능합니다.
- **스도쿠 해결**: 빈 칸에 숫자를 채워넣고 유효성을 검사하며 진행하는 방식이 동일합니다.

## 추천 문제
- **백준 14888 (연산자 끼워넣기)**: 정해진 수의 연산자를 나열하여 최대/최소 결과를 만드는 문제 (순열 구조 유사)
- **백준 15686 (치킨 배달)**: M개의 치킨집을 선택하여 거리를 최소화하는 문제 (조합 문제이나 백트래킹 연습에 좋음)
- **백준 2098 (외판원 순회)**: DFS에 비트마스크 DP를 결합해야 하는 심화 문제

## 종합 평가
문제의 제약 조건(N<=10)을 정확히 파악하여 DFS/백트래킹을 선택한 판단이 훌륭합니다. 코드는 군더더기 없이 깔끔하며 백트래킹의 핵심 로직을 정확하게 구현하고 있습니다. `nonlocal` 사용이나 라이브러리 활용 같은 파이썬 특유의 기능을 더 익힌다면 더욱 세련된 코드를 작성할 수 있을 것입니다.
