# 리코쳇 로봇

#BFS #그래프탐색 #최단경로 #알고리즘 #코딩테스트

## 문제 난이도: 중

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| N (행 개수) | 3 ~ 100 | 격자의 세로 크기 |
| M (열 개수) | 3 ~ 100 | 격자의 가로 크기 |
| 격자 총 크기 | 최대 10,000 | N × M = 100 × 100 |
| 시간 제한 | 약 1초 (추정) | 프로그래머스 기본 시간 제한 |
| 메모리 제한 | 약 128MB (추정) | 충분한 메모리 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=100 (격자 크기 10,000) | 판정 |
|--------|--------------------------|------|
| O(N×M) | 10,000 ✅ | 매우 여유 |
| O((N×M)²) | 100,000,000 ⚠️ | 경계 |
| O((N×M) × max(N,M)) | 1,000,000 ✅ | 충분 |

**이 문제의 경우**:
- 격자 크기: 최대 100 × 100 = 10,000
- BFS 탐색 시 각 상태(위치)를 한 번씩만 방문
- 각 상태에서 4방향으로 슬라이딩 → 최대 O(max(N,M)) 이동
- **총 복잡도**: O(N × M × max(N,M)) = O(10,000 × 100) = O(1,000,000)
- **결론**: O(N × M × max(N,M)) 이하의 알고리즘 필요 ✅

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **최소 이동 횟수** (최적해) | 완전탐색 중 BFS가 적합 |
| 순서가 중요한가 | 이동 순서가 결과에 영향 | 경로 탐색 필요 |
| 부분 문제로 나눌 수 있는가 | 이전 상태와 무관하게 현재 위치에서 최적 결정 | BFS의 레벨 단위 탐색 적합 |
| 탐욕적 선택이 최적인가 | ❌ 아님 | 여러 경로 비교 필요 |

**특수한 이동 규칙**:
- 일반 BFS와 달리 **한 칸씩 이동이 아님**
- 한 방향으로 **장애물/벽에 부딪힐 때까지 미끄러짐**
- 목표 지점(G)도 통과 가능 (정확히 멈춰야 함)

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: BFS (너비 우선 탐색)

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - "최소 이동 횟수"를 구하는 문제 → BFS는 가중치 없는 그래프에서 최단 경로 보장
   - 각 이동(슬라이딩)을 하나의 간선(가중치 1)으로 볼 수 있음
   - 처음 목표에 도달한 시점이 곧 최소 이동 횟수

2. **제약 조건 충족**
   - 시간 복잡도: O(N × M × max(N,M)) → 최대 1,000,000회 연산 (✅ 통과)
   - 공간 복잡도: O(N × M) → 최대 10,000개 상태 저장 (✅ 통과)

3. **핵심 인사이트**
   - "최소 몇 번" = 최단 거리 문제 = BFS
   - 슬라이딩 이동은 다음 상태 계산 방식만 다를 뿐, BFS 프레임워크 적용 가능
   - 방문 체크: 같은 위치에 더 적은 이동으로 도달한 적 있으면 스킵

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| DFS | O(4^k) (k=이동 횟수) | 최단 경로 보장 불가, 모든 경로 탐색 시 지수 복잡도 |
| 다익스트라 | O(E log V) | 모든 간선 가중치가 1이므로 BFS로 충분, 오버스펙 |
| DP | - | 상태 전이가 방향성 없음 (순환 가능), 적용 어려움 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "최소 이동", "최단 거리", "몇 번 만에 도달", "도달 불가능하면 -1"
- **문제 유형**: 
  - 미로 탈출 (기본 BFS)
  - 빙판/얼음 위 이동 (슬라이딩 BFS) ← **이 문제**
  - 나이트 이동, 특수 규칙 이동
- **주의사항**: 
  - 슬라이딩 시 목표 지점(G)도 **지나칠 수 있음** (멈추는 조건: 벽 또는 장애물)
  - 방문 체크는 "정지 위치" 기준으로 해야 함

---

## 2. 🧠 자연어 실행 흐름

(코드 없이 순수 한글로 작성)

1. **초기화**: 
   - 보드에서 시작점(R)과 목표점(G)의 좌표를 찾는다
   - BFS용 큐에 (시작 행, 시작 열, 이동 횟수 0)을 넣는다
   - 방문 배열을 만들어 시작점을 방문 처리한다

2. **BFS 탐색 시작**: 큐가 빌 때까지 반복한다

3. **현재 상태 꺼내기**: 큐에서 (현재 행, 현재 열, 현재 이동 횟수)를 꺼낸다

4. **목표 도달 체크**: 현재 위치가 목표점(G)이면 현재 이동 횟수를 반환한다

5. **4방향 슬라이딩 탐색**: 상, 하, 좌, 우 각 방향에 대해:
   - 현재 위치에서 해당 방향으로 한 칸씩 이동한다
   - 보드 밖으로 나가거나 장애물(D)을 만나면 멈춘다
   - 멈춘 위치(장애물/벽 직전)가 이동 후 도착 위치이다
   - 도착 위치가 시작점과 같다면(이동 없음) 스킵한다
   - 도착 위치를 방문한 적 없다면:
     - 방문 처리한다
     - 큐에 (도착 행, 도착 열, 이동 횟수 + 1)을 넣는다

6. **탐색 종료**: 큐가 비었는데 목표에 도달하지 못했다면 -1을 반환한다

---

## 3. 💻 Code Implementation

(언어: Python)
```python
from collections import deque

def solution(board):
    n = len(board)
    m = len(board[0])
    
    # 시작점(R)과 목표점(G) 찾기
    start = goal = None
    for i in range(n):
        for j in range(m):
            if board[i][j] == 'R':
                start = (i, j)
            elif board[i][j] == 'G':
                goal = (i, j)
    
    # 4방향: 상, 하, 좌, 우
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # BFS 초기화
    queue = deque([(start[0], start[1], 0)])  # (행, 열, 이동 횟수)
    visited = [[False] * m for _ in range(n)]
    visited[start[0]][start[1]] = True
    
    while queue:
        r, c, moves = queue.popleft()
        
        # 목표 도달 체크
        if (r, c) == goal:
            return moves
        
        # 4방향 슬라이딩 탐색
        for dr, dc in directions:
            nr, nc = r, c
            
            # 벽이나 장애물에 부딪힐 때까지 슬라이딩
            while 0 <= nr + dr < n and 0 <= nc + dc < m and board[nr + dr][nc + dc] != 'D':
                nr += dr
                nc += dc
            
            # 이동이 없거나 이미 방문한 경우 스킵
            if (nr, nc) == (r, c) or visited[nr][nc]:
                continue
            
            # 새 위치 방문 처리 및 큐에 추가
            visited[nr][nc] = True
            queue.append((nr, nc, moves + 1))
    
    # 목표에 도달할 수 없음
    return -1
```

**복잡도 분석**
- 시간: O(N × M × max(N, M))
  - 각 위치는 최대 한 번 방문: O(N × M)
  - 각 위치에서 4방향 슬라이딩: O(max(N, M))
- 공간: O(N × M)
  - 방문 배열: O(N × M)
  - 큐에 저장되는 상태: 최대 O(N × M)

---

# 평가

## 개선할 점

1. **디버깅용 `print` 문 제거 필요**
   - 62번 줄의 `print(y,x,moves)`는 제출 시 반드시 제거해야 합니다
   - 프로그래머스에서는 출력이 많으면 시간 초과 원인이 될 수 있음

2. **방향 배열 정의 시 오타 주의**
   - 초기 코드에서 `directions = [(-1,0),(1,0),(1,0),(-1,0)]`로 작성하여 좌/우 이동이 누락됨
   - 코딩 테스트에서 방향 벡터는 **가장 흔한 오타 원인** 중 하나
   - **팁**: 상수로 미리 정의하거나, 작성 후 반드시 한 번 검증

   ```python
   # 권장: 명시적 상수 정의
   UP, DOWN, LEFT, RIGHT = (-1, 0), (1, 0), (0, -1), (0, 1)
   directions = [UP, DOWN, LEFT, RIGHT]
   ```

3. **`is_wall` 함수 위치 최적화**
   - 현재 `solution` 함수 내부에 중첩 함수로 정의됨
   - 매 호출마다 클로저 접근이 발생하므로, 인라인으로 작성하거나 외부 함수로 분리하면 미세하게 성능 향상 가능
   - 단, 가독성을 위해 현재 방식도 충분히 좋은 선택

4. **조건 체크 순서 최적화**
   - 79~84번 줄에서 방문 체크 후 이동 없음 체크 순서
   - 이동이 없으면 당연히 현재 위치이므로 방문됨 → 순서 상관없지만, 논리적으로 "이동 없음"을 먼저 체크하는 것이 더 명확

## 잘한 점

1. **문제 분석 주석이 훌륭함**
   - 1~28번 줄까지 문제 접근 방식을 체계적으로 정리
   - "미끄러진다"의 의미를 명확히 파악하고 슬라이딩 로직 설계
   - 실행 흐름을 단계별로 명시하여 구현 시 가이드 역할

2. **자료구조 선택이 적절함**
   - `set`을 사용하여 방문 체크 O(1) 보장
   - `deque`를 사용하여 BFS 큐 연산 효율화

3. **슬라이딩 로직 구현이 정확함**
   - `while not is_wall(ny+dy, nx+dx)` 패턴으로 "부딪히기 직전까지" 이동을 정확히 구현
   - 이동 전 다음 칸을 미리 검사하는 방식이 버그 방지에 효과적

4. **엣지 케이스 처리**
   - 이동이 없는 경우(`(ny,nx) == (y,x)`) 스킵 처리
   - 도달 불가 시 `-1` 반환

## 다른 응용 방안

1. **빙판 미로 탈출** (얼음 위 미끄러지는 퍼즐)
2. **당구공 이동 시뮬레이션** (벽에 부딪힐 때까지 이동)
3. **레이저 반사 경로 계산** (거울에 닿을 때까지 직진)
4. **퍼즐 게임 최소 이동** (Sokoban, 슬라이딩 퍼즐 등)
5. **로봇 청소기 경로 탐색** (한 방향으로 끝까지 이동 후 회전)

## 추천 문제

| 문제 | 유형 | 포인트 |
|------|------|--------|
| [프로그래머스 - 게임 맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844) | 기본 BFS | 1칸씩 이동하는 표준 BFS |
| [백준 13460 - 구슬 탈출 2](https://www.acmicpc.net/problem/13460) | 슬라이딩 BFS | 두 구슬 동시 이동 + 복잡한 조건 |
| [백준 3197 - 백조의 호수](https://www.acmicpc.net/problem/3197) | BFS + 시뮬레이션 | 얼음이 녹는 조건 추가 |
| [백준 2206 - 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206) | 상태 확장 BFS | 벽 파괴 여부를 상태에 포함 |
| [프로그래머스 - 미로 탈출](https://school.programmers.co.kr/learn/courses/30/lessons/159993) | 2단계 BFS | 레버를 당긴 후 출구로 이동 |

## 종합 평가

**BFS 슬라이딩 문제의 핵심을 정확히 파악하고 구현했습니다.**

문제 분석 단계에서 "미끄러진다"의 의미를 명확히 정의하고, 실행 흐름을 주석으로 체계화한 점이 좋습니다. 이러한 습관은 복잡한 문제에서 구현 실수를 줄여줍니다.

다만, **방향 벡터 오타**로 인해 디버깅 시간을 소모했습니다. 코딩 테스트에서 방향 배열은 실수가 잦은 부분이므로, 다음 전략을 권장합니다:

1. **템플릿화**: 자주 쓰는 방향 벡터를 미리 저장해두고 복붙
2. **검증 습관**: 작성 후 "상=y감소, 하=y증가, 좌=x감소, 우=x증가" 체크
3. **테스트 케이스**: 4방향 모두 이동하는 간단한 케이스로 먼저 검증

슬라이딩 BFS 패턴은 백준 구슬 탈출 시리즈에서 심화 형태로 자주 출제되니, 이 문제를 기반으로 확장 연습을 권장합니다.
