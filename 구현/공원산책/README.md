# 공원 산책

#구현 #시뮬레이션 #2차원배열

# 문제 난이도 {하}

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| H, W (공원 크기) | 3 ~ 50 | 매우 작음. 격자 전체 탐색도 가능 |
| routes 길이 | 1 ~ 50 | 명령 개수도 매우 적음 |
| n (이동 거리) | 1 ~ 9 | 한 번의 이동 거리도 작음 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=50 |
|--------|---------|
| O(N) | 50 ✅ |
| O(N^2) | 2,500 ✅ |
| O(N^3) | 125,000 ✅ |

**이 문제의 경우**:
- 전체 명령을 수행하며 이동하는 시뮬레이션입니다.
- 명령 수(50) * 이동 거리(9) = 최대 450번의 좌표 갱신/검사.
- **결론**: **O(M * K)** (M: 명령 수, K: 이동 거리)로 아주 여유롭게 통과 가능.

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 그대로 구현 | 그대로 구현 | 시뮬레이션(Implementation) |
| 이동 조건 | 격자 내 & 장애물 X | 경계 검사 + 장애물 검사 필요 |
| 중단 조건 | 조건 불만족 시 명령 무시 | 이동 전 '검증' 로직 선행 필요 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: [시뮬레이션 (구현)]

**선택 근거 (Why this algorithm?)**

1.  **문제 구조와의 적합성**
    - 문제에서 주어진 명령(방향, 거리)을 순서대로 수행하며 상태(위치)를 갱신하는 전형적인 시뮬레이션 문제입니다.

2.  **제약 조건 충족**
    - 입력 크기가 매우 작아(50x50), 매 명령마다 한 칸씩 이동하며 체크해도 연산량이 거의 없습니다.

3.  **핵심 인사이트**
    - "명령을 수행하기 전에... 확인합니다" → 이동하다가 막히면 *원래 위치 유지*.
    - 즉, 이동 후의 위치를 바로 갱신하지 말고, '이동 가능한지 미리 가보는' 가상 이동 검사가 필요합니다.

#### ❌ 기각된 대안들

- BFS/DFS: 최단 거리를 찾는 문제가 아니므로 불필요. 단순히 과정만 따라가면 됨.

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "명령에 따라 이동", "범위를 벗어나면 무시", "장애물"
- **주의사항**:
    - (0, 0) 좌표계 방향 주의 (N, S, W, E 매핑).
    - "이동 중 장애물을 만나면" -> 최종 위치뿐만 아니라 지나가는 경로에 장애물이 있는지 확인해야 함.

---

## 2. 🧠 자연어 실행 흐름

1.  **초기화**:
    - 주어진 `park` 배열을 순회하여 시작 지점 'S'의 좌표 `(h, w)`를 찾습니다.
    - 방향 정보를 딕셔너리로 정의합니다. (`op`: `[dh, dw]`)
        - N: [-1, 0], S: [1, 0], W: [0, -1], E: [0, 1]
2.  **명령 처리 루프**:
    - `routes`의 각 명령 `op n`에 대해 반복합니다.
    - 현재 위치 `(current_h, current_w)`를 임시 변수 `(temp_h, temp_w)`에 복사합니다.
    - 이동 가능 여부 플래그 `valid`를 True로 설정합니다.
3.  **이동 검증 (Step-by-Step)**:
    - 1부터 `n`까지 반복하며 한 칸씩 이동해봅니다.
    - 다음 좌표 `(next_h, next_w)`를 계산합니다.
    - **검사 1**: 공원 범위를 벗어나는지 확인 (0 <= h < H, 0 <= w < W). 벗어나면 `valid = False`, 루프 중단.
    - **검사 2**: 장애물('X')인지 확인. 장애물이면 `valid = False`, 루프 중단.
    - 통과하면 `(temp_h, temp_w)`를 업데이트합니다.
4.  **위치 갱신**:
    - `valid`가 True라면 실제 위치 `(h, w)`를 `(temp_h, temp_w)`로 업데이트합니다.
    - False라면 명령을 무시하고(위치 유지) 다음 명령으로 넘어갑니다.
5.  모든 명령 처리 후 `[h, w]`를 반환합니다.

---

## 3. 💻 Code Implementation

(언어: Python)
```python
def solution(park, routes):
    H = len(park)
    W = len(park[0])
    
    # 1. 시작 위치 찾기
    h, w = 0, 0
    for i in range(H):
        for j in range(W):
            if park[i][j] == "S":
                h, w = i, j
                break
                
    # 2. 방향 정의 (N, S, W, E)
    directions = {
        "N": (-1, 0),
        "S": (1, 0),
        "W": (0, -1),
        "E": (0, 1)
    }
    
    # 3. 명령 처리
    for route in routes:
        op, n = route.split()
        n = int(n)
        dh, dw = directions[op]
        
        # 이동 전 검증을 위한 임시 좌표
        temp_h, temp_w = h, w
        valid = True
        
        # 한 칸씩 이동하며 검사
        for _ in range(n):
            temp_h += dh
            temp_w += dw
            
            # 범위 체크
            if not (0 <= temp_h < H and 0 <= temp_w < W):
                valid = False
                break
            
            # 장애물 체크
            if park[temp_h][temp_w] == "X":
                valid = False
                break
        
        # 유효하다면 위치 갱신
        if valid:
            h, w = temp_h, temp_w
            
    return [h, w]
```

**복잡도 분석**
- 시간: O(Routes * N + ParkSize). ParkSize는 시작점 찾기에 사용. Routes(50) * N(9) = 매우 작음.
- 공간: O(1). 추가 메모리 거의 안 씀.

# 평가

## 개선할 점
- **디버깅 코드 제거**: `print(directions['N'])`와 같은 디버깅용 코드는 제출 시 제거하는 것이 좋습니다.
- **중복 로직 단순화**: 45행의 '도착 지점 범위 체크' 로직은 50행의 반복문 내부에서도 수행되고 있습니다. 직사각형 그리드에서는 도착점이 내부라면 경로도 내부임이 보장되지만, 장애물 체크 로직과 통일성을 위해 반복문 내부에서 한 번에 처리하는 것이 코드 흐름상 더 간결할 수 있습니다.
- **구조분해 할당 활용**: `(direction, steps) = route.split(" ")` 부분은 잘 작성되었습니다. 다만 `steps`를 바로 `int`로 변환하여 받을 수 없으므로 현재처럼 별도 줄에서 변환하는 것은 적절합니다. `op, n = route.split()` `n = int(n)` 패턴을 유지하면 좋습니다.

## 잘한 점
- **단계별 검증 (Step-by-step)**: 이동하는 '모든 칸'에 대해 장애물 여부를 확인해야 한다는 문제의 핵심 요구사항을 루프(`range(1, steps+1)`)를 통해 정확하게 구현했습니다. (단순히 도착점만 확인하면 틀리는 문제입니다.)
- **명확한 변수명**: `current_y`, `current_x`, `temp_y`, `temp_x` 등 변수명이 역할에 맞게 잘 지어부 되어 코드를 읽기 편합니다.
- **2차원 배열 탐색 정석**: `dy`, `dx` 방향 벡터를 활용한 좌표 이동 방식이 깔끔하게 구현되었습니다.

## 다른 응용 방안
- **체스/장기 말 이동**: 나이트나 비숍처럼 이동 경로에 다른 말이 있으면 못 가는 규칙 구현에 활용됩니다.
- **게임 충돌 처리**: 캐릭터가 벽이나 장애물을 통과하지 못하게 하는 물리 엔진의 기초 로직이 됩니다.

## 추천 문제
- **프로그래머스 [PCCP 기출문제] 1번 / 붕대 감기**: 시뮬레이션 유형의 또 다른 기초 문제입니다.
- **프로그래머스 경주로 건설**: BFS를 활용하지만 이동 방향과 비용을 고려해야 하는 심화 격자 문제입니다.
- **백준 14503 로봇 청소기**: 방향 전환과 조건에 따른 이동이 결합된 전형적인 삼성 기출 시뮬레이션입니다.

## 종합 평가
문제의 핵심인 '이동 경로상의 장애물 체크'를 정확히 파악하고 구현했습니다. 코드의 가독성이 좋고 로직의 흐름이 자연스럽습니다. 다만 제출 전 불필요한 `print` 문을 제거하는 습관과, 로직의 중복을 줄여 코드를 더 간결하게 만드는 연습을 하면 더욱 완성도 높은 코드가 될 것입니다.
