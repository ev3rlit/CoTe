# 빛의 경로 사이클

#구현 #시뮬레이션 #그래프 #코딩테스트

# 문제 난이도 중

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| `grid` 크기 (R x C) | 최대 500 x 500 | 총 격자 칸 수는 최대 250,000개 |
| 방향 (Direction) | 4개 | 각 격자마다 4가지 방향으로 빛이 들어올 수 있음 |
| 전체 상태 수 (N) | 1,000,000 | (500 * 500 * 4). 모든 상태를 한 번씩 방문해도 충분함 |
| 시간 제한 | 일반적 (약 10초) | O(N)으로 충분히 통과 가능 |
| 메모리 제한 | 일반적 | `visited` 배열 (bool, 100만개) 생성 시 약 수 MB 소요 (여유 있음) |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=1,000 | N=10,000 | N=100,000 | N=1,000,000 |
|--------|---------|----------|-----------|-------------|
| O(N) | 1,000 ✅ | 10,000 ✅ | 100,000 ✅ | 1,000,000 ✅ |
| O(N log N) | 10,000 ✅ | 130,000 ✅ | 1,700,000 ✅ | 20,000,000 ✅ |
| O(N²) | 1,000,000 ✅ | 10^8 ⚠️ | 10^10 ❌ | 10^12 ❌ |

**이 문제의 경우**:
- 상태의 총 개수 $N = R \times C \times 4 \approx 1,000,000$ (최악의 경우)
- 각 상태는 정확히 하나의 다음 상태를 가짐 (Functional Graph).
- 모든 상태를 1번씩만 방문하면 사이클을 모두 찾을 수 있음.
- **결론**: **O(R·C) (= O(N))** 알고리즘 필요 (선형 시간 복잡도).

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 모든 사이클 길이 | 완전 탐색 (Brute Force) 혹은 시뮬레이션 |
| 순서가 중요한가 | 중요함 | 빛의 이동 방향과 순서에 따라 경로 결정 |
| 상태의 정의 | (행, 열, 방향) | 3차원 배열 `visited[r][c][d]` 필요 |
| 사이클의 특성 | 모든 노드 차수 1 | 반드시 사이클로 분할됨 (꼬리 달린 사이클 없음) |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 시뮬레이션 (Simulation) & 그래프 순회

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 각 격자의 각 방향에서 나가는 빛의 경로는 유일하게 결정됩니다 (Deterministic).
   - 들어오는 빛에 대해서도 유일하게 결정되므로, 모든 정점의 In-degree와 Out-degree가 1입니다.
   - 따라서 그래프는 여러 개의 상호 배타적인 **단수 사이클(Simple Cycle)**들로 분해됩니다.

2. **제약 조건 충족**
   - 시간 복잡도: 전체 상태 수(1,000,000)만큼만 순회하면 됨 → O(R·C).
   - 공간 복잡도: 방문 여부를 저장할 배열 → O(R·C). 100만 bool은 메모리 문제 없음.

3. **핵심 인사이트**
   - **"방문하지 않은 상태(행, 열, 방향)에서 출발해서 다시 그 상태로 돌아올 때까지 이동하면 하나의 사이클이 완성된다."**
   - 격자를 벗어나면 반대편으로 돌아오는 처리는 모듈러 연산(`%`)으로 해결.

---

### 1.5 🔬 핵심 개념 상세 해설

#### 💡 왜 "모든 상태가 반드시 사이클로 분해"되는가?

이 문제의 핵심을 이해하려면 **Functional Graph (함수 그래프)**의 특성을 알아야 합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│  Functional Graph란?                                             │
│  각 노드가 정확히 하나의 나가는 간선(Out-edge)만 가지는 그래프     │
│                                                                  │
│  예시:  A → B → C → D → B (B에서 사이클 형성)                     │
│                                                                  │
│  이 문제에서:                                                     │
│  - 노드 = (행, 열, 들어오는 방향)                                 │
│  - 각 노드에서 다음으로 갈 곳은 딱 1개로 결정됨                   │
└─────────────────────────────────────────────────────────────────┘
```

**핵심 포인트**: 이 문제에서는 **들어오는 간선도 정확히 1개**입니다.

```
일반적인 Functional Graph        이 문제의 그래프
      ↓                               ↓
    A → B → C                     A ↔ B ↔ C
        ↑                         (양방향 1:1 매핑)
        D
                                  
꼬리가 있을 수 있음              꼬리 없이 순수 사이클만 존재!
```

**왜 들어오는 간선도 1개인가?**
- 빛이 (r, c)에 방향 d로 들어왔다면, 그 빛은 **유일한 이전 상태**에서 온 것입니다.
- 예: (1, 2)에 "위에서" 들어왔다면 → (0, 2)에서 "아래로" 나온 것이 유일한 경로

따라서 **모든 노드가 In-degree = Out-degree = 1** → **순수 사이클들로만 구성**

---

#### 🧭 방향 전환 로직 상세 설명

**방향 인덱스 정의** (시계방향):
```
       0: 상 (↑)
         │
3: 좌 ←─┼─→ 1: 우
         │
       2: 하 (↓)

인덱스:  상=0, 우=1, 하=2, 좌=3
```

**방향 전환 규칙**:
```python
# 현재 방향 d에서...
if char == 'S':  # 직진
    next_d = d           # 방향 유지
    
if char == 'L':  # 좌회전 (반시계방향)
    next_d = (d - 1) % 4  
    # 상(0) → 좌(3), 우(1) → 상(0), 하(2) → 우(1), 좌(3) → 하(2)
    
if char == 'R':  # 우회전 (시계방향)
    next_d = (d + 1) % 4  
    # 상(0) → 우(1), 우(1) → 하(2), 하(2) → 좌(3), 좌(3) → 상(0)
```

**시각적 예시**:
```
빛이 '위에서 아래로(↓)' 들어올 때 (d = 2)

┌───────────┬───────────┬───────────┐
│    'S'    │    'L'    │    'R'    │
│           │           │           │
│     ↓     │     ↓     │     ↓     │
│     ↓     │     →     │     ←     │
│  d=2→d=2  │  d=2→d=1  │  d=2→d=3  │
│  (직진)   │ (우로꺾임) │ (좌로꺾임) │
└───────────┴───────────┴───────────┘
```

---

#### 🔄 격자 래핑 (Wrapping) 처리

격자 밖으로 나가면 **반대편에서 다시 들어옵니다**:

```
예: 3x3 격자에서 오른쪽 끝에서 더 오른쪽으로 가면?

  열 0   열 1   열 2
 ┌─────┬─────┬─────┐
 │     │     │  →  │──┐
 ├─────┼─────┼─────┤  │ 래핑!
 │     │     │     │  │
 ├─────┼─────┼─────┤  │
 │     │     │     │  │
 └─────┴─────┴─────┘  │
   ↑                   │
   └───────────────────┘
   
   열 2에서 오른쪽(+1) → 열 3 
   → (3 % 3) = 0 → 열 0으로 나타남
```

**코드로 표현**:
```python
next_r = (curr_r + dr[curr_d]) % rows  # 행 래핑
next_c = (curr_c + dc[curr_d]) % cols  # 열 래핑
```

---

#### 📊 구체적 예시로 사이클 추적하기

**입력**: `["SL", "LR"]` (2x2 격자)

```
     열 0   열 1
    ┌─────┬─────┐
행 0│  S  │  L  │
    ├─────┼─────┤
행 1│  L  │  R  │
    └─────┴─────┘
```

**(0, 0)에서 방향 0(위→아래)으로 시작하는 사이클 추적:**

```
Step 1: (0,0,0) → 'S'이므로 직진 → 방향 0 유지
        다음 위치: (0+1, 0) = (1, 0), 방향 0
        
Step 2: (1,0,0) → 'L'이므로 좌회전 → 방향 (0-1)%4 = 3(좌)
        다음 위치: (1, 0-1) = (1, -1) → 래핑 → (1, 1), 방향 3
        
Step 3: (1,1,3) → 'R'이므로 우회전 → 방향 (3+1)%4 = 0(하)
        다음 위치: (1+1, 1) = (2, 1) → 래핑 → (0, 1), 방향 0
        
Step 4: (0,1,0) → 'L'이므로 좌회전 → 방향 (0-1)%4 = 3(좌)
        다음 위치: (0, 1-1) = (0, 0), 방향 3
        
Step 5: (0,0,3) → 'S'이므로 직진 → 방향 3 유지
        다음 위치: (0, 0-1) = (0, -1) → 래핑 → (0, 1), 방향 3
        
... (계속 추적하면 시작점으로 돌아옴)
```

**총 상태 수**: 2 × 2 × 4 = 16개
**모든 상태가 여러 사이클로 분할됨**

---

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| DFS/BFS (일반 탐색) | - | 단순 탐색과 비슷하지만, 갈림길이 없으므로 굳이 재귀나 큐를 쓸 필요 없이 `while` 루프로 충분함. |
| Union-Find | O(N Ack(N)) | 연결 요소만 찾을 뿐 사이클의 길이를 구하는 과정이 추가로 필요하므로 비효율적. |

---

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "격자", "거울/빛", "사이클", "방향 전환"
- **문제 유형**: 2차원 격자에서의 시뮬레이션 + 방문 체크.
- **주의사항**:
  - 격자 밖으로 나갈 때 반대편으로 나오는 처리 (`row = (row + dr) % R`).
  - Python의 경우 재귀 제한(Recursion Limit) 주의 (여기서는 `while` 권장).

---

## 2. 🧠 자연어 실행 흐름

(코드 없이 순수 한글로 작성. 단계별 번호 매김)

1. **초기화**:
   - `height`, `width` 크기 확인.
   - `visited[height][width][4]` 3차원 불리언 배열 생성 (모두 `False`).
   - 방향 벡터 정의: `directions` (상, 우, 하, 좌 시계방향 순서).
   - `R`은 우회전 `(d + 1) % 4`, `L`은 좌회전 `(d - 1) % 4`.

2. **전체 상태 순회**:
   - 3중 반복문 (`y`, `x`, `d`)을 통해 모든 가능한 시작 상태를 확인.
   - 만약 `not visited[y][x][d]` (아직 방문 안 함)라면:
     - 새로운 사이클 탐색 시작 (길이 `count = 0`).
     - 현재 상태 `(current_y, current_x, current_d)` 저장.

3. **사이클 추적 (Simulation)**:
   - `while` 루프:
     - 현재 상태 방문 처리 `visited[current_y][current_x][current_d] = True`.
     - `count` 증가.
     - 현재 위치의 격자 값(`S`, `L`, `R`)에 따라 다음 방향 결정.
     - 다음 위치 `ny`, `nx` 계산 (모듈러 연산으로 격자 래핑).
     - 만약 다음 상태가 이미 방문된 상태라면 루프 종료.
     - 현재 상태를 업데이트하고 계속 진행.

4. **결과 저장**:
   - 탐색이 끝난 사이클의 길이 `count`를 결과 리스트 `answer`에 추가.

5. **최종 반환**:
   - `answer`를 오름차순 정렬하여 반환.

---

## 3. 💻 Code Implementation

(언어: Python)
```python
def solution(grid):
    answer = []
    height, width = len(grid), len(grid[0])
    
    # 방향 정의: 상(0), 우(1), 하(2), 좌(3) - 시계방향
    # (dy, dx) 형태
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    # 방문 체크: visited[y][x][d]
    visited = [[[False] * 4 for _ in range(width)] for _ in range(height)]
    
    for y in range(height):
        for x in range(width):
            for d in range(4):
                if not visited[y][x][d]:
                    # 새로운 사이클 발견
                    count = 0
                    current_y, current_x, current_d = y, x, d
                    
                    while not visited[current_y][current_x][current_d]:
                        visited[current_y][current_x][current_d] = True
                        count += 1
                        
                        # 현재 격자에서 방향 전환
                        # 'S': 직진 (d 그대로)
                        # 'L': 좌회전 (d - 1) % 4
                        # 'R': 우회전 (d + 1) % 4
                        char = grid[current_y][current_x]
                        if char == 'L':
                            current_d = (current_d - 1) % 4
                        elif char == 'R':
                            current_d = (current_d + 1) % 4
                        # 'S'는 current_d 그대로
                        
                        # 다음 좌표 이동 (격자 래핑)
                        dy, dx = directions[current_d]
                        current_y = (current_y + dy) % height
                        current_x = (current_x + dx) % width
                    
                    # 사이클 종료, 길이 저장
                    answer.append(count)
    
    answer.sort()
    return answer

# 시간 복잡도: O(height * width * 4) -> 모든 상태를 정확히 한 번씩 방문하므로 O(N).
# 공간 복잡도: O(height * width * 4) -> visited 배열.
```

**복잡도 분석**
- 시간: O(height × width) (모든 노드와 간선을 1회씩 방문)
- 공간: O(height × width) (방문 배열 사용)

---

# 평가

## 개선할 점

### 1. 방향 인덱스 `d` 관리가 이중으로 되어 있음
```python
# 현재 코드
dy,dx = directions[(d-1)%len(directions)]
d = d-1  # d를 따로 업데이트

# 개선 방향: d만 업데이트하고, dy/dx는 이동 시점에 계산
if char == 'L':
    d = (d - 1) % 4
elif char == 'R':
    d = (d + 1) % 4

dy, dx = directions[d]  # 이동 직전에 한 번만 계산
```

### 2. visited 키로 `(cy, cx, dy, dx)` 대신 `(cy, cx, d)` 사용 권장
- 튜플 4개 → 3개로 줄여서 메모리와 해시 계산 비용 절감
- 방향 인덱스 `d`만으로 충분히 상태를 구분할 수 있음

### 3. `len(directions)` 대신 상수 `4` 사용
- 방향은 고정된 4개이므로 `4`로 직접 명시하면 가독성 향상
- 매 반복마다 `len()` 호출하는 오버헤드 제거

### 4. 파일명 오타
- `soultion.py` → `solution.py` (오타 수정 필요)

## 잘한 점

- **set 자료구조 선택**: 방문 체크를 `set()`으로 구현하여 O(1) 조회
- **모듈러 연산 활용**: 격자 래핑을 `% height`, `% width`로 깔끔하게 처리
- **주석 작성**: 각 단계별로 주석을 남겨 코드 흐름 파악이 용이
- **변수 네이밍**: `cy, cx` (current y/x), `dy, dx` 등 일관된 네이밍

## 다른 응용 방안

이 문제에서 익힌 패턴은 다음 상황에 적용 가능:

| 상황 | 적용 포인트 |
|------|------------|
| **로봇 청소기** | 방향 전환 + 시뮬레이션 |
| **뱀 게임** | 좌표 이동 + 래핑 처리 |
| **순환 검출** | Functional Graph에서 사이클 찾기 |
| **거울/레이저 문제** | 빛의 경로 추적 |
| **토러스 구조** | 모듈러 연산으로 경계 처리 |

## 추천 문제

| 문제 | 플랫폼 | 유사 포인트 |
|------|--------|------------|
| [로봇 청소기 (14503)](https://www.acmicpc.net/problem/14503) | 백준 | 방향 전환 + 시뮬레이션 |
| [뱀 (3190)](https://www.acmicpc.net/problem/3190) | 백준 | 방향 전환 + 좌표 이동 |
| [경주로 건설](https://school.programmers.co.kr/learn/courses/30/lessons/67259) | 프로그래머스 | 방향 상태를 포함한 BFS |
| [리코쳇 로봇](https://school.programmers.co.kr/learn/courses/30/lessons/169199) | 프로그래머스 | 슬라이딩 + 사이클 |

## 종합 평가

이 문제는 **Functional Graph(함수 그래프)** 개념을 이해해야 풀 수 있는 문제로, 단순 시뮬레이션보다 난이도가 높습니다. "왜 모든 상태가 반드시 사이클로 분해되는가?"라는 핵심 통찰이 없으면 접근 자체가 어려운 문제입니다.

**따라 풀면서 얻어가야 할 것들**:

1. **상태 정의의 중요성**: `(y, x, 방향)`을 하나의 노드로 보는 관점
2. **Functional Graph 특성**: In-degree = Out-degree = 1이면 순수 사이클만 존재
3. **방향 인덱스 관리**: `(d ± 1) % 4`로 좌/우회전 처리
4. **격자 래핑**: 모듈러 연산으로 토러스(원환면) 구조 처리

이 문제를 완전히 이해했다면, 비슷한 유형의 **방향 전환 + 상태 기반 시뮬레이션** 문제에서 빠르게 접근할 수 있습니다. 다음에는 직접 풀어보기 전에 "상태를 어떻게 정의할 것인가?"를 먼저 고민해보세요.
