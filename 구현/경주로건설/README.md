# 경주로 건설

#구현 #BFS #Dijkstra #3차원방문처리 #코딩테스트

# 문제 난이도 상

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| N (입력 크기) | 3 ~ 25 | 맵 크기가 최대 25x25로 매우 작음 |
| 시간 제한 | ?초 | 정확한 명시는 없으나, N이 작으므로 복잡한 로직도 허용됨 |
| 메모리 제한 | ?MB | - |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=10 | N=25 | N=50 |
|--------|---------|----------|-----------|
| O(N^2 * 4) | 400 ✅ | 2,500 ✅ | 10,000 ✅ |
| O(N^4) | 10,000 ✅ | 390,625 ✅ | 6,250,000 ✅ |

**이 문제의 경우**:
- N = 최대 25 이므로
- 맵 전체 칸 수 = 25 * 25 = 625칸
- 각 칸마다 4가지 방향 상태를 가질 수 있음. 총 상태 수 = 625 * 4 = 2500개
- **결론**: O(N^3) 또는 O(N^4) 수준의 알고리즘도 충분히 통과 가능. 상태 공간이 작으므로 어떤 탐색 알고리즘(BFS, DFS, Dijkstra)을 써도 시간 복잡도보다는 **구현의 정확성**이 핵심인 문제.

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 최적해 (최소 비용) | BFS 또는 Dijkstra |
| 가중치 여부 | 있음 (직선 100, 코너 600) | 단순 BFS(거리) 불가능. 비용을 고려해야 함. |
| 상태 정의 | 좌표(y, x)만으로 충분한가? | ❌ 아님. **진입 방향**에 따라 다음 비용이 달라짐(코너 여부). |
| 방문 처리 | 단순 2차원 배열? | ❌ **3차원 배열(y, x, direction)** 필요. |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: [BFS_with_Cost_Update (또는 Dijkstra)]

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 최소 비용을 구하는 문제이며, 간선의 가중치(비용)가 양수입니다.
   - N이 작아 다익스트라나 BFS 모두 가능하지만, 이 문제는 **'코너'**라는 특수 조건 때문에 **이전 이동 방향**을 상태에 포함시켜야 합니다.

2. **제약 조건 충족**
   - 상태 공간 크기: 25 * 25 * 4 = 2500
   - 간선 수: 각 상태에서 최대 3~4방향 이동 가능
   - 연산 횟수 매우 적음 -> 시간 복잡도 문제 없음

3. **핵심 인사이트**
   - 일반적인 미로 찾기는 `visited[y][x]`로 충분함.
   - 하지만 여기서는 (y, x)에 '위에서' 도착했을 때와 '왼쪽에서' 도착했을 때, 다음 이동(예: 오른쪽으로 이동) 비용이 다름. (직선 vs 코너)
   - 따라서 **방문 처리를 (y, x, dir) 3차원으로 하거나, 각 칸에 도달하는 최소 비용을 2차원이 아닌 3차원 배열로 관리**해야 함.

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 단순 BFS | O(N^2) | 가중치가 1이 아님(비용 다름). 단순 큐 사용 시 최소 비용 보장 안됨. |
| DFS | O(4^(N^2)) | 최단 경로/최소 비용 보장 어려움. N이 작아도 비효율적. |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "회전", "방향 전환 비용", "거울 설치"
- **문제 유형**: 가중치가 상태(이전 방향 등)에 따라 동적으로 변하는 최단 경로 문제.
- **주의사항**: `visited[y][x]`만 쓰면 안 됨! `visited[y][x][dir]`를 기억해야 함.

---

## 2. 🧠 자연어 실행 흐름

1. **초기화**:
   - `costs` 3차원 배열 생성: `costs[y][x][dir]` (초기값: 무한대). 크기는 `N x N x 4`.
   - 큐(Queue) 생성 및 시작점 추가. 시작점 (0,0)에서는 비용 0. 방향은 '없음'(-1) 또는 4방향 모두 가능하다고 가정 처리.

2. **탐색 (While Queue)**:
   - 큐에서 `(y, x, prev_dir, current_cost)`를 꺼냄.
   - (y, x)가 도착점이면 답 갱신. (하지만 최소 비용 갱신형이므로 끝까지 탐색 권장)

3. **이동 시도 (4방향)**:
   - 상, 하, 좌, 우 4방향에 대해 루프.
   - 다음 좌표 `(ny, nx)`가 범위 내이고 벽(1)이 아닌지 확인.

4. **비용 계산 및 갱신**:
   - 추가 비용 계산: 기본 100원.
   - 만약 `prev_dir`과 현재 이동 방향 `new_dir`이 다르면(코너) +500원 추가. (단, `prev_dir`이 -1(시작점)인 경우는 코너 비용 없음)
   - `new_cost = current_cost + calc_cost`
   - **핵심**: `new_cost < costs[ny][nx][new_dir]` 이라면 비용 갱신하고 큐에 추가.
     - (참고: 문제에 따라 `>=` 등호가 필요할 수도 있으나, 다익스트라/BFS 최적화에서는 `<`가 일반적)

5. **결과 반환**:
   - 도착점 `(N-1, N-1)`의 4방향 비용 중 최솟값 반환.

---

## 3. 💻 Code Implementation

(언어: Python)
```python
from heapq import heappop, heappush

def solution(board):
    
    N = len(board)
    dirs = [(-1,0),(0,1),(1,0),(0,-1)]
    INF = float('inf')
    
    # 3차원 상태를 Dictionary로 관리 (y, x, dy, dx) -> cost
    # 초기화: 모든 상태 무한대
    costs = {}
    for y in range(N):
        for x in range(N):
            for (dy,dx) in dirs:
                costs[(y,x,dy,dx)] = INF
    
    pq = []
    
    # 시작점 초기화 (0,0)
    # 시작점에서는 아직 방향이 없지만, 편의상 모든 방향에서의 진입 비용을 0으로 처리하거나
    # 예외 처리가 필요함. 여기서는 시작점에서 이동 가능한 방향으로 바로 탐색하도록 구현.
    if board[0][0] == 0:
        for (dy,dx) in dirs:
            costs[(0,0,dy,dx)] = 0
            # 초기 상태: 비용 0, 위치(0,0), 이전 방향(0,0 - 시작점 표시)
            # 주의: prev_dy, prev_dx가 (0,0)이면 시작점이라는 약속
            # 여기서는 큐에 넣을 때 (cost, y, x, prev_dy, prev_dx)
        heappush(pq, (0,0,0,0,0))
    
    min_cost = INF
    
    while pq:
        cost, y,x, prev_dy,prev_dx = heappop(pq)
        
        # 가지치기: 현재 경로의 비용이 이미 기록된 최소 비용보다 크면 스킵 (Lazy Update)
        # Dictionary 키: (y,x,prev_dy,prev_dx)가 아닌 (y,x,현재_진입_방향)이어야 정확함.
        # 코드 구조상 prev_dy, prev_dx는 '이 칸에 들어올 때의 방향'을 의미하므로 
        # costs[(y,x,prev_dy,prev_dx)]와 비교하는 것이 맞음.
        # 단, 시작점(0,0) 처리를 위해 예외 조건 추가
        if (prev_dy, prev_dx) != (0,0) and costs[(y,x,prev_dy,prev_dx)] < cost:
            continue
        
        # 도착 확인
        if (y,x) == (N-1,N-1):
            min_cost = min(min_cost, cost)
            continue
        
        # 4방향 이동
        for (dy,dx) in dirs:
            ny,nx = y + dy, x + dx
            
            # 경계 확인
            if not(0 <= ny < N and 0 <= nx < N):
                continue
            
            # 벽 확인
            if board[ny][nx] == 1:
                continue
                
            # 비용 계산
            next_cost = cost + 100
            # 코너 확인: 시작점이 아니고, 이동 방향이 이전 방향과 다르면 코너 비용 추가
            if (0,0) != (prev_dy,prev_dx) and (dy,dx) != (prev_dy,prev_dx):
                next_cost += 500
                
            # 최소 비용 갱신
            # 상태의 키는 (ny, nx, dy, dx) 즉, (다음 위치, 그 위치로 진입한 방향)
            if next_cost < costs[(ny,nx,dy,dx)]:
                costs[(ny,nx,dy,dx)] = next_cost
                heappush(pq,(next_cost,ny,nx,dy,dx))
    
    return min_cost
```

**복잡도 분석**
- 시간: O(N^2 * 4 * log(N^2 * 4)) - 다익스트라 (정점 수: N^2*4, 간선 수: N^2*4*4)
- 공간: O(N^2 * 4) - 비용 저장을 위한 Dictionary

---

# 평가

## 개선할 점
- **초기 비용 최적화 (Lazy Deletion)**: `heappop` 직후에 `costs` 값과 `cost`를 비교하여 이미 더 짧은 경로가 발견되었다면 건너뛰는 로직(Lazy Deletion)을 추가하면 중복 연산을 더 줄일 수 있습니다. (현재 코드에도 주석으로 설명되어 있으나 명시적인 `continue` 조건이 중요합니다)
- **Start Point 처리**: `heappush(pq, (0,0,0,0,0))`에서 `prev_dy, prev_dx`를 `(0,0)`으로 설정하여 시작점을 표시한 아이디어는 좋습니다. 다만 `costs` 딕셔너리 초기화 시 모든 방향값에 0을 넣는 부분과 큐에 넣는 부분이 약간 중복될 수 있으니, 큐에 넣는 것만으로 충분할 수 있습니다.

## 잘한 점
- **Dictionary 활용**: 3차원 리스트 `arr[y][x][d]` 대신 `dict[(y,x,dy,dx)]`를 사용하여 직관적이고 명시적으로 상태를 관리했습니다. 특히 방향을 인덱스(0,1,2,3)가 아닌 벡터 `(dy,dx)` 자체로 키로 사용한 점이 가독성에 매우 좋습니다.
- **다익스트라 전환**: BFS의 한계를 깨닫고 우선순위 큐를 사용한 다익스트라로 적절히 변경했습니다.
- **코너 비용 로직**: `(0,0) != (prev_dy,prev_dx)` 조건을 추가하여 시작점에서의 방향 전환 예외 처리를 깔끔하게 해결했습니다.

## 다른 응용 방안
- **상태가 복잡한 그래프 탐색**: 열쇠 보유 여부, 벽 부수기 횟수 등 상태가 (y, x) 외에 추가적으로 필요한 모든 최단 거리 문제에 `Dictionary + Tuple Key` 방식이 유용합니다.

## 추천 문제
- **[프로그래머스] 빛의 경로 사이클**: 들어온 방향과 나가는 방향의 관계를 다루는 또 다른 시뮬레이션 문제입니다. 딕셔너리나 3차원 배열 활용 능력을 키우기 좋습니다.

## 종합 평가
본인의 코딩 스타일(Dictionary 선호, 명시적인 변수 사용)을 살리면서 문제의 핵심인 **'방향에 따른 비용 차이'**를 잘 해결했습니다.
특히 방향 인덱스 대신 `(dy,dx)` 튜플 자체를 상태 키로 사용한 점은 파이토닉하고 가독성이 뛰어난 접근입니다. 다익스트라의 핵심인 '갱신될 때만 큐에 넣기'도 잘 구현되어 정석적인 풀이로 보입니다.
