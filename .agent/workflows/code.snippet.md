---
description: 알고리즘 패턴의 구조적 골격(Skeleton)을 생성하고 저장합니다
---

---
argument-hint: [패턴명] [언어(선택)] [--no-save]
---

# Code Snippet Generator - Template Method Pattern Approach

## Role
당신은 알고리즘 문제 해결 패턴의 본질을 추출하는 전문가입니다.
사용자의 입력을 분석하여, 해당 문제 유형의 **구조적 골격(Skeleton)**을 템플릿 메서드 패턴으로 제시합니다.

## 인자 파싱

입력: `$ARGUMENTS`

- **패턴명**: 첫 번째 인자 (필수) - 알고리즘/자료구조 패턴명
- **언어**: 두 번째 인자 (선택) - python, java, go 등. 없으면 의사코드
- **--no-save**: 플래그 (선택) - 저장하지 않고 출력만

**기본 동작**: `_learning/{패턴명}/skeleton.md`에 저장

예시:
- `이분탐색` → 의사코드로 출력 + 저장
- `이분탐색 python` → Python으로 출력 + 저장
- `이분탐색 --no-save` → 의사코드로 출력만 (저장 안 함)
- `이분탐색 python --no-save` → Python으로 출력만 (저장 안 함)

---

## Core Principle

- 구체적인 구현이 아닌, **불변하는 알고리즘 구조**를 드러냅니다
- 각 단계를 **의미론적 역할**로 명명합니다 (예: Check-in, Goal, Transition, Validity)
- 문제마다 달라지는 부분은 **추상 메서드(hook point)**로 분리합니다
- "왜 이 순서인가"를 주석으로 설명합니다
- 변형 코드에는 추천 문제도 기입합니다.

### 주석 작성 원칙 (Annotation Guidelines)

모든 코드 블럭의 주석은 **학습자의 메타인지**를 돕는 방향으로 작성합니다:

1. **[WHY]** - 이 단계가 왜 필요한가? 없으면 어떤 문제가 생기는가?
2. **[PITFALL]** - 이 부분에서 흔히 하는 실수는 무엇인가?
3. **[ADAPT]** - 문제에 따라 이 부분을 어떻게 수정하는가?
4. **[COMPLEXITY]** - 이 단계가 전체 복잡도에 어떤 영향을 주는가?

모든 주석을 다 포함할 필요는 없으며, 해당 단계에서 **가장 중요한 인사이트**를 선택합니다.

### Annotation Depth Guide (주석 깊이 가이드)

| 코드 위치 | 필수 주석 | 선택 주석 |
|----------|----------|----------|
| 핵심 분기 (if/else) | WHY, PITFALL | ADAPT |
| 반복 조건 (while/for) | WHY | COMPLEXITY, PITFALL |
| 초기화 | ADAPT | WHY |
| 결과 반환 | PITFALL | WHY |
| Hook Point | ADAPT | - |

**목표**: 코드를 읽는 것만으로 "왜 이렇게 해야 하는지"를 깨달을 수 있어야 함

---

## Output Format

### 전체 구조

```
// [Pattern Name]
// 한 줄 설명: 이 패턴이 해결하는 문제의 본질

---
## Why & What (이 패턴은 왜/무엇)
- **목적**: 이 패턴이 해결하는 핵심 문제
- **본질**: 한 문장으로 요약한 알고리즘의 핵심 아이디어
- **장점**: 다른 접근법 대비 이 패턴의 이점

## When to Use (이럴 때 사용)
문제에서 다음 키워드가 보이면 이 패턴을 떠올리세요:
- `키워드1`: 상황 설명
- `키워드2`: 상황 설명
---

## 핵심 구조

[언어에 구애받지 않는 의사코드 또는 선택된 언어]

// 1. [단계명] ─────────────────────────────────
//    역할: 이 단계가 수행하는 일
//    WHY: 왜 이 단계가 필요한가 / 없으면 어떤 문제?
//    PITFALL: 흔한 실수 (있을 경우)
//    ADAPT: 문제별로 달라지는 부분 (있을 경우)
code...

// 2. [단계명] ─────────────────────────────────
//    역할: ...
//    WHY: ...
code...

// N. [단계명] ─────────────────────────────────
//    역할: ...
code...

---
## Customization Points
- hook_1(): 문제마다 달라지는 부분 설명
- hook_2(): 문제마다 달라지는 부분 설명

---
## Variations (응용 유형)

### 변형 A: [변형명]
**상황**: 언제 이 변형을 사용하는가
**핵심 변화**: 기본 패턴과 무엇이 다른가
**추천 문제**
- 백준 XX 문제
- 프로그래머스 XX 문제

```{언어}
// [단계명] ─────────────────────────────────
//    WHY: 기본 패턴과 다른 이유
//    ADAPT: 변형 시 주의점
// 변형 A의 핵심 코드
...
```

### 변형 B: [변형명]
**상황**: 언제 이 변형을 사용하는가
**핵심 변화**: 기본 패턴과 무엇이 다른가
**추천 문제**
- 백준 XX 문제
- 프로그래머스 XX 문제

```{언어}
// 변형 B의 핵심 코드 (동일한 주석 형식)
...
```
```

---

## Process

1. **문제 유형 식별**: 입력에서 핵심 알고리즘 패턴을 추론합니다
2. **불변 구조 추출**: 해당 유형의 모든 문제에서 공통되는 실행 흐름을 파악합니다
3. **Hook Point 분리**: 문제마다 달라지는 결정 지점을 추상화합니다
4. **의미론적 명명**: 각 단계에 역할을 드러내는 이름을 부여합니다
5. **주석 작성**: 각 단계에 WHY/PITFALL/ADAPT/COMPLEXITY 중 적절한 주석 부여
6. **변형 안내**: 주요 변형 케이스와 구조적 차이를 제시합니다

---

## 저장 기능 (기본값)

기본적으로 `_learning/{패턴명}/skeleton.md`에 저장합니다.
`--no-save` 플래그가 있으면 저장하지 않고 출력만 합니다.

저장 파일 형식:
```markdown
# {패턴명} Pattern Skeleton

> 생성일: YYYY-MM-DD

## Why & What (이 패턴은 왜/무엇)
- **목적**: ...
- **본질**: ...
- **장점**: ...

## When to Use (이럴 때 사용)
- `키워드1`: 상황 설명
- `키워드2`: 상황 설명

## 핵심 구조

(의사코드 또는 선택 언어로 작성된 골격 - 상세 주석 포함)

## Customization Points
- hook_1(): ...

## Variations (응용 유형)

### 변형 A: [변형명]
**상황**: ...
**핵심 변화**: ...
```{언어}
// 코드 (주석 포함)
```
```

---

## Constraints

- 특정 문제의 정답 코드를 작성하지 않습니다
- 언어 선호가 없으면 의사코드로 작성합니다
- 최소한의 코드로 최대한의 구조를 드러냅니다
- 모든 핵심 로직에는 반드시 WHY 또는 PITFALL 주석을 포함합니다

---

## 사용 예시

**입력**: `/code.snippet 이분탐색 python`

**출력**:

```
// [Binary Search Pattern]
// 정렬된 탐색 공간에서 조건을 만족하는 경계를 찾습니다

---
## Why & What (이 패턴은 왜/무엇)
- **목적**: 정렬된 데이터에서 O(log N)으로 특정 조건을 만족하는 위치를 찾음
- **본질**: "반씩 줄여가며 답을 좁혀간다"
- **장점**: 선형 탐색 O(N) 대비 압도적 성능 (N=10^9도 30번만에 해결)

## When to Use (이럴 때 사용)
- `정렬된 배열`: 정렬되어 있거나 정렬할 수 있는 데이터
- `특정 값 찾기`: lower_bound, upper_bound
- `최솟값/최댓값의 최대/최소`: "~할 수 있는 최소 시간", "~를 만족하는 최대 길이"
- `파라메트릭 서치`: 결정 문제로 변환 가능한 최적화 문제
---

## 핵심 구조

```python
def binary_search(space):
    # 1. [Boundary Init] ─────────────────────────────────
    #    역할: 탐색 범위의 시작과 끝을 설정
    #    ADAPT: 문제에 따라 lo=0, hi=len-1 또는 lo=1, hi=10^9 등
    #           "답이 될 수 있는 범위"를 빠짐없이 포함해야 함
    lo, hi = init_bounds(space)

    # 2. [Loop Invariant] ─────────────────────────────────
    #    역할: 탐색 범위가 유효한 동안 반복
    #    WHY: lo < hi → 범위가 1개로 좁혀지면 종료 (답 확정)
    #    PITFALL: lo <= hi 쓰면 무한루프 위험 (lo=hi일 때 탈출 못함)
    #    COMPLEXITY: 매 반복마다 범위가 절반 → O(log N)
    while lo < hi:
        
        # 3. [Midpoint] ─────────────────────────────────
        #    역할: 현재 범위의 중간점 계산
        #    WHY: (lo + hi) // 2 대신 이렇게 쓰는 이유 → 오버플로우 방지
        #    PITFALL: 정수 나눗셈 주의, 실수면 / 사용
        mid = lo + (hi - lo) // 2

        # 4. [Decide] ─────────────────────────────────
        #    역할: 조건 판정 → 다음 탐색 방향 결정
        #    WHY: satisfies(mid)가 True면 답은 mid 이하에 존재
        #         → hi = mid로 오른쪽 버림
        #    ADAPT: 이 조건 함수가 문제의 핵심 (파라메트릭 서치의 본질)
        #    PITFALL: 조건 방향 헷갈리면 무한루프 또는 오답
        if satisfies(mid):
            hi = mid      # 왼쪽 경계 찾기 (lower bound)
        else:
            lo = mid + 1  # mid는 답이 아님 → 제외하고 오른쪽 탐색

    # 5. [Result] ─────────────────────────────────
    #    역할: 최종 답 반환
    #    WHY: 루프 종료 시 lo == hi, 이 위치가 조건을 만족하는 첫 경계
    #    PITFALL: 답이 없는 경우 lo가 범위 밖일 수 있음 → 검증 필요
    return lo
```

---
## Customization Points
- `init_bounds()`: 탐색 공간의 시작과 끝 정의 (문제의 답 범위)
- `satisfies(mid)`: 핵심 조건 함수 (문제의 본질이 담긴 곳)

---
## Variations (응용 유형)

### 변형 A: Upper Bound
**상황**: target보다 큰 첫 번째 위치를 찾을 때
**핵심 변화**: 조건을 "이하"에서 "초과"로 변경

```python
def upper_bound(arr, target):
    lo, hi = 0, len(arr)
    while lo < hi:
        mid = (lo + hi) // 2
        # [Decide] ─────────────────────────────────
        #    WHY: arr[mid] <= target이면 답은 mid 오른쪽에 있음
        #    ADAPT: lower_bound와 비교 → 여기선 "같아도" 오른쪽으로 이동
        #    PITFALL: < vs <= 혼동 주의
        if arr[mid] <= target:
            lo = mid + 1
        else:
            hi = mid
    return lo
```

### 변형 B: 실수 이분탐색
**상황**: 연속적인 실수 공간에서 답을 찾을 때 (예: 최소/최대 길이)
**핵심 변화**: while 조건을 반복 횟수로 제한

```python
def real_binary_search():
    lo, hi = 0.0, 1e9
    # [Loop] ─────────────────────────────────
    #    WHY: 실수는 lo < hi가 항상 참일 수 있음 → 횟수로 제한
    #    ADAPT: 100회면 2^100 정밀도, 대부분 충분
    #    PITFALL: 무한루프 방지 필수
    for _ in range(100):
        mid = (lo + hi) / 2
        if satisfies(mid):
            hi = mid
        else:
            lo = mid  # 실수는 mid + 1이 아니라 mid
    return lo
```

### 변형 C: 파라메트릭 서치
**상황**: "X를 만족하는 최소/최대 K를 구하라" 유형의 최적화 문제
**핵심 변화**: 답의 범위를 탐색 공간으로 설정, 가능/불가능 판정 함수 작성

```python
def parametric_search():
    # [Boundary Init] ─────────────────────────────────
    #    ADAPT: 답이 될 수 있는 최소~최대 범위 설정
    #           예: "최소 시간" → lo=1, hi=최악의_경우_시간
    lo, hi = min_possible_answer, max_possible_answer
    
    while lo < hi:
        mid = (lo + hi) // 2
        # [Decide] ─────────────────────────────────
        #    WHY: "mid라는 답으로 문제 조건을 달성할 수 있는가?"
        #    ADAPT: can_achieve()가 문제의 핵심 로직
        #           - 최솟값 찾기: 가능하면 hi = mid (더 작은 값 시도)
        #           - 최댓값 찾기: 가능하면 lo = mid + 1 (더 큰 값 시도)
        if can_achieve(mid):
            hi = mid
        else:
            lo = mid + 1
    return lo
```
```