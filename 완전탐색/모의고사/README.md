# 모의고사

#완전탐색 #알고리즘 #코딩테스트

# 문제 난이도 하

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| N (입력 크기) | 10,000 | `answers`의 최대 길이. O(N) 또는 O(N log N) 충분 |
| 시간 제한 | - | 통상 1초 가정 시 여유로움 |
| 메모리 제한 | - | 특별한 제약 없음 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=10,000 | 가능 여부 |
|--------|---------|----------|
| O(N) | 10,000 | ✅ 매우 여유로움 |
| O(N log N) | ~130,000 | ✅ 여유로움 |
| O(N²) | 100,000,000 | ⚠️ 아슬아슬함 (Python은 위험할 수 있음) |

**이 문제의 경우**:
- N = 10,000 이므로 O(N^2)도 동작할 수 있으나, 단순 비교이므로 굳이 복잡하게 할 필요 없음.
- **결론**: O(N)의 선형 탐색으로 충분히 해결 가능.

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 모든 경우 비교 | 단순히 주어진 패턴대로 채점만 하면 됨 |
| 순서가 중요한가 | 중요함 | 문제 번호 순서대로 비교 |
| 반복되는 패턴 | 존재함 | 주기성을 가진 수열 (Modulo 연산 활용) |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 완전탐색 (단순 구현)

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 수포자 3명의 찍는 방식이 고정된 패턴으로 반복됩니다.
   - 입력 배열 `answers`를 한 번 순회하면서 각 수포자의 패턴과 비교하면 점수를 계산할 수 있습니다.

2. **제약 조건 충족**
   - 시간 복잡도: O(N) → N=10,000일 때 10,000회 연산 (✅ 통과)
   - 공간 복잡도: O(1) → 점수 저장용 변수 및 고정된 패턴 배열만 사용

3. **핵심 인사이트**
   - 패턴의 길이가 서로 다르므로 (5, 8, 10), 인덱스를 접근할 때 `index % pattern_length`를 사용하면 순환 구조를 쉽게 구현할 수 있습니다.

#### ❌ 기각된 대안들

없음. (너무 직관적인 문제라 다른 알고리즘을 고려할 필요가 없음)

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "반복되는", "패턴", "가장 많이 맞힌 사람"
- **문제 유형**: 단순 시뮬레이션, 구현, 완전탐색
- **주의사항**:
    - 가장 높은 점수를 받은 사람이 '여럿'일 수 있다는 점 (오름차순 정렬 반환)
    - 인덱스 나머지 연산 실수 주의 (`i % len(pattern)`)

---

## 2. 🧠 자연어 실행 흐름

1. 수포자 1, 2, 3의 찍기 패턴을 배열로 정의한다.
   - P1: [1, 2, 3, 4, 5]
   - P2: [2, 1, 2, 3, 2, 4, 2, 5]
   - P3: [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
2. 각 수포자의 점수를 저장할 배열 `scores`를 [0, 0, 0]으로 초기화한다.
3. 정답 배열 `answers`를 처음부터 끝까지 순회한다 (인덱스 `i`).
4. 각 `i`에 대해:
   - `if answers[i] == P1[i % len(P1)]`: scores[0] 증가
   - `if answers[i] == P2[i % len(P2)]`: scores[1] 증가
   - `if answers[i] == P3[i % len(P3)]`: scores[2] 증가
5. `scores` 배열에서 최댓값(`max_score`)을 찾는다.
6. `scores`를 다시 순회하며 `max_score`와 같은 점수를 가진 수포자의 번호(1-based)를 결과 리스트에 담는다.
7. 결과 리스트를 오름차순으로 정렬하여 반환한다 (순서대로 담았으면 이미 정렬되어 있음).

---

## 3. 💻 Code Implementation

(언어: Python)
```python
def solution(answers):
    # 1. 수포자들의 찍기 패턴 정의
    pattern1 = [1, 2, 3, 4, 5]
    pattern2 = [2, 1, 2, 3, 2, 4, 2, 5]
    pattern3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    
    # 2. 점수 집계 (init 0)
    scores = [0, 0, 0]
    
    # 3. 정답 채점 (O(N))
    for i, answer in enumerate(answers):
        # 모듈러 연산(%)을 통해 패턴의 인덱스 순환
        if answer == pattern1[i % len(pattern1)]:
            scores[0] += 1
        if answer == pattern2[i % len(pattern2)]:
            scores[1] += 1
        if answer == pattern3[i % len(pattern3)]:
            scores[2] += 1
            
    # 4. 가장 높은 점수 확인
    max_score = max(scores)
    
    # 5. 최고 득점자 추출
    result = []
    for i, score in enumerate(scores):
        if score == max_score:
            result.append(i + 1) # 사람은 1번부터 시작하므로 +1
            
    return result

# 복잡도 분석
# 시간: O(N) - answers 길이만큼 1회 순회
# 공간: O(1) - 고정 크기의 패턴 배열과 점수 변수만 사용
```
