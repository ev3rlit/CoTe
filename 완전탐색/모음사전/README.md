# 모음사전

#완전탐색 #알고리즘 #코딩테스트

# 문제 난이도 중

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| word 길이 | 1 ~ 5 | 최대 5글자 단어 |
| 사용 가능 문자 | A, E, I, O, U (5개) | 5진법과 유사한 구조 |
| 전체 단어 수 | 5 + 25 + 125 + 625 + 3125 = 3905개 | 완전탐색 충분히 가능 |
| 시간 제한 | - | 통상 1초 가정 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

**전체 단어 개수 분석**:
- 길이 1: 5개
- 길이 2: 5² = 25개
- 길이 3: 5³ = 125개
- 길이 4: 5⁴ = 625개
- 길이 5: 5⁵ = 3125개
- **총합**: 3905개 → O(3905) ✅ 매우 여유로움

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 특정 단어의 순서 찾기 | 사전순 생성 or 수학 공식 |
| 순서가 중요한가 | 예 (사전 순서) | DFS 순서 = 사전 순서 |
| 규칙성이 있는가 | 예 (5진법 유사 구조) | 수학 공식으로 O(1) 가능 |
| 입력 크기 | 매우 작음 (3905개) | 완전탐색 확정 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: DFS 완전탐색 또는 수학 공식

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 사전의 단어 순서는 DFS 탐색 순서와 동일
   - 빈 문자열 → A 추가 → AA 추가 → AAA → AAAA → AAAAA → 백트래킹 → AAAAE → ...
   - DFS로 순회하며 카운트하다가 목표 단어를 찾으면 반환

2. **제약 조건 충족**
   - 시간 복잡도: O(5⁵) = O(3905) → 매우 여유로움 (✅ 통과)
   - 공간 복잡도: O(5) → 재귀 깊이 최대 5 (✅ 통과)

3. **핵심 인사이트**
   - **DFS 순서 = 사전 순서**: A → AA → AAA → AAAA → AAAAA → AAAAE → ...
   - 또는 **수학 공식**: 각 자리별 가중치 계산 (781, 156, 31, 6, 1)

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 모든 단어 생성 후 정렬 | O(N log N) | 가능하지만 메모리 낭비 |
| BFS | O(N) | 가능하지만 DFS가 사전 순서에 자연스러움 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "사전 순서", "N번째", "모든 조합", "알파벳 조합"
- **문제 유형**: 순열/조합 생성, 사전식 순서 문제
- **주의사항**:
    - DFS 탐색 순서가 사전 순서와 일치하는지 확인
    - 빈 문자열도 카운트에 포함되는지 확인 (이 문제는 길이 1 이상)

---

## 2. 🧠 자연어 실행 흐름

### 방법 1: DFS 완전탐색
1. **DFS 함수 정의**: 현재 문자열을 파라미터로 받음
2. **방문 시 카운트 증가**: 현재 문자열을 "방문"할 때마다 카운트 증가
3. **목표 도달 확인**: 현재 문자열 == word이면 카운트 반환
4. **길이 제한 확인**: 길이가 5면 더 이상 깊이 들어가지 않음
5. **자식 탐색**: A, E, I, O, U 순서로 다음 문자 추가하며 재귀
6. **결과 반환**: 목표 단어를 찾으면 즉시 반환

### 방법 2: 수학 공식
1. **자리별 가중치 계산**: 각 자리에서 다음 모음으로 넘어갈 때 건너뛰는 단어 수
   - 1번째 자리: 1 + 5 + 25 + 125 + 625 = 781
   - 2번째 자리: 1 + 5 + 25 + 125 = 156
   - 3번째 자리: 1 + 5 + 25 = 31
   - 4번째 자리: 1 + 5 = 6
   - 5번째 자리: 1
2. **각 문자의 인덱스 계산**: A=0, E=1, I=2, O=3, U=4
3. **총 순서 계산**: Σ(각 자리 문자 인덱스 × 해당 자리 가중치) + 길이

---

## 3. 💻 Code Implementation

### 방법 1: DFS 완전탐색
```python
def solution(word):
    vowels = ['A', 'E', 'I', 'O', 'U']
    result = [0]  # 리스트로 감싸서 내부 함수에서 수정 가능
    found = [False]
    
    def dfs(current):
        # 현재 문자열 방문 (길이 1 이상이면 카운트)
        if current:
            result[0] += 1
            if current == word:
                found[0] = True
                return
        
        # 길이 5 도달 시 종료
        if len(current) == 5:
            return
        
        # A, E, I, O, U 순서로 탐색
        for v in vowels:
            if found[0]:
                return
            dfs(current + v)
    
    dfs('')
    return result[0]
```

### 방법 1-2: DFS 완전탐색 (반환값 + 상태 인자 방식)
클로저 없이 순수하게 인자와 반환값만 사용하는 방식입니다.

```python
def solution(word):
    vowels = ['A', 'E', 'I', 'O', 'U']
    
    def dfs(current, count):
        """
        current: 현재까지 만든 문자열
        count: 현재까지 방문한 단어 수
        
        반환값: (찾았는지 여부, 최종 카운트)
        """
        # 현재 문자열 방문 (길이 1 이상이면 카운트)
        if current:
            count += 1
            if current == word:
                return (True, count)  # 찾음!
        
        # 길이 5 도달 시 종료
        if len(current) == 5:
            return (False, count)
        
        # A, E, I, O, U 순서로 탐색
        for v in vowels:
            found, count = dfs(current + v, count)
            if found:
                return (True, count)  # 찾았으면 즉시 반환
        
        return (False, count)  # 못 찾음
    
    found, result = dfs('', 0)
    return result
```

**두 방식 비교**

| 항목 | 클로저 방식 | 반환값 + 상태 인자 방식 |
|------|------------|----------------------|
| 상태 관리 | `result[0]`, `found[0]` 외부 변수 | 함수 인자와 반환값 |
| 부수 효과 | 있음 (외부 변수 수정) | 없음 (순수 함수) |
| 가독성 | 짧고 직관적 | 명시적이고 예측 가능 |
| 디버깅 | 외부 상태 추적 필요 | 인자/반환값만 확인 |
| 함수형 스타일 | ❌ | ✅ |

### 방법 2: 수학 공식 (O(1))
```python
def solution(word):
    # 각 자리별 가중치: i번째 자리에서 다음 모음으로 넘어갈 때 건너뛰는 단어 수
    # 5번째 자리: 1
    # 4번째 자리: 1 + 5 = 6
    # 3번째 자리: 1 + 5 + 25 = 31
    # 2번째 자리: 1 + 5 + 25 + 125 = 156
    # 1번째 자리: 1 + 5 + 25 + 125 + 625 = 781
    weights = [781, 156, 31, 6, 1]
    vowel_to_idx = {'A': 0, 'E': 1, 'I': 2, 'O': 3, 'U': 4}
    
    result = 0
    for i, char in enumerate(word):
        # 해당 문자까지 도달하는 데 필요한 단어 수
        result += vowel_to_idx[char] * weights[i] + 1
    
    return result
```

**복잡도 분석**

| 방법 | 시간 | 공간 |
|------|------|------|
| DFS 완전탐색 | O(5⁵) = O(3905) | O(5) 재귀 깊이 |
| 수학 공식 | O(L) = O(5) | O(1) |

---

# 평가

## 개선할 점
- **변수명 일관성**: README에서는 `vowels`로, solution.py에서는 `characters`로 사용합니다. 일관된 네이밍이 좋습니다.
- **수학 공식 구현 누락**: solution.py에 O(1) 수학 공식 버전(`solutionv3`)이 없습니다. 실제 코테에서는 가장 효율적인 버전으로 제출하는 것이 좋습니다.
- **Docstring 위치**: solutionv2의 docstring이 `if current:` 다음에 오면 더 자연스럽습니다. 현재는 함수 시작 직후에 있어 표준적이지만, 빈 줄이 불필요하게 있습니다.

## 잘한 점
- **두 가지 DFS 패턴 비교 구현**: 클로저 방식(v1)과 반환값+인자 방식(v2)을 모두 구현하여 패턴 학습에 효과적입니다.
- **상세한 사고 과정 주석**: 코드 상단 13줄의 주석이 문제 분석 과정을 잘 보여줍니다.
- **시간 복잡도 계산**: "5^1 + ... + 5^5 = 1만 미만"이라는 계산을 명시하여 완전탐색 근거를 제시했습니다.
- **튜플 반환으로 다중 상태 전달**: `(found, count)` 튜플 반환으로 깔끔하게 상태를 전달합니다.
- **선택 가능한 solution 함수**: `solution(word) = solutionv2(word)`로 호출하여 버전 교체가 용이합니다.

## 다른 응용 방안
- **사전식 순서 생성**: 암호 생성기, 조합 열거
- **N진법 변환**: 특정 진법의 숫자 순서 계산
- **트리 순회 순서**: DFS 순서가 특정 순서와 일치하는 문제

## 추천 문제
- **백준 1759: 암호 만들기** — 조합 생성 + 조건 검증
- **백준 15649~15652: N과 M 시리즈** — 순열/조합 DFS 패턴
- **프로그래머스: 불량 사용자** — DFS + 집합 조합

## 종합 평가
DFS 순서 = 사전 순서라는 핵심 인사이트를 정확히 파악하고, 두 가지 구현 패턴(클로저 vs 반환값)을 모두 익힌 점이 좋습니다.
주석에서 "되돌아오려면 백트래킹을 해야하네?"라는 의문이 있었는데, 실제로는 명시적 백트래킹 없이도 재귀 반환으로 자연스럽게 처리됩니다.
다만 O(1) 수학 공식 버전도 구현해두면 **"완전탐색 vs 수학적 최적화"**의 트레이드오프를 체험할 수 있습니다.
