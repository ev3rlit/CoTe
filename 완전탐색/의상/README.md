# 의상

#해시 #조합 #수학 #코딩테스트

## 문제 난이도: 중

## 문제 링크
[프로그래머스 - 의상](https://school.programmers.co.kr/learn/courses/30/lessons/42578)

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| 의상 수 | 1 ~ 30개 | 매우 작음, 완전탐색도 가능 |
| 의상 종류 | 최대 30종 | 종류별로 최소 1개 |
| 문자열 길이 | 1 ~ 20 | 해시맵 키로 사용 가능 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 접근 방식 | 복잡도 | N=30 | 결과 |
|----------|--------|------|------|
| 모든 조합 완전탐색 | O(2^N) | 2^30 ≈ 10억 | ❌ |
| 종류별 카운팅 후 곱셈 | O(N) | 30 | ✅ |

**이 문제의 경우**:
- 완전탐색은 2^30 = 10억으로 시간 초과
- **결론**: O(N) 수학적 접근 필요

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 경우의 수 **개수** | 조합 공식 |
| 순서가 중요한가 | ❌ (상의+하의 = 하의+상의) | 조합 |
| 각 그룹에서 선택 | 0개 또는 1개 | **곱의 법칙** |
| 제약 조건 | 최소 1개 이상 착용 | -1 처리 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 해시맵 + 수학적 조합

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 각 종류는 **독립적**으로 선택
   - 각 종류에서 **0개 또는 1개** 선택
   - **곱의 법칙** 적용 가능

2. **제약 조건 충족**
   - 시간 복잡도: O(N) → 30회 연산 (✅ 통과)
   - 공간 복잡도: O(K) → K는 종류 수 (✅ 통과)

3. **핵심 인사이트**
   ```
   종류별 선택지 = 의상 수 + 1 (안 입는 경우)
   전체 조합 = 모든 종류의 선택지 곱
   최종 답 = 전체 조합 - 1 (아무것도 안 입는 경우 제외)
   ```

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| DFS 완전탐색 | O(2^N) | N=30이면 10억 연산, 시간 초과 |
| 조합 라이브러리 | O(2^N) | 모든 조합 생성 시 동일 문제 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "서로 다른 조합의 수", "각 그룹에서 선택"
- **문제 유형**: 독립적인 그룹에서 0~1개 선택하는 경우의 수
- **공식**: `(n1+1) × (n2+1) × ... × (nk+1) - 1`
- **주의사항**: 아무것도 선택 안 하는 경우 반드시 제외 (`-1`)

---

## 2. 🧠 자연어 실행 흐름

1. **종류별 의상 개수 카운팅**
   - 해시맵에 {종류: 개수} 형태로 저장

2. **조합 계산**
   - 각 종류마다 (개수 + 1)을 곱함
   - +1은 "이 종류를 안 입는 경우"

3. **예외 처리**
   - 결과에서 1을 뺌 (아무것도 안 입는 경우 제외)

4. **결과 반환**

---

## 3. 💻 Code Implementation

```python
from collections import defaultdict

def solution(clothes):
    # 1. 종류별 의상 개수 카운팅
    category_count = defaultdict(int)
    for name, category in clothes:
        category_count[category] += 1
    
    # 2. 조합 계산: (각 종류 개수 + 1) 전부 곱하기
    result = 1
    for count in category_count.values():
        result *= (count + 1)  # +1은 "안 입는 경우"
    
    # 3. 아무것도 안 입는 경우 제외
    return result - 1
```

**복잡도 분석**
- 시간: O(N) - 의상 순회 1회
- 공간: O(K) - K는 종류 수

---

## 4. 수학적 증명

### 예시: 상의 2개, 하의 3개

| 종류 | 의상 수 | 선택지 (안 입음 포함) |
|------|---------|----------------------|
| 상의 | 2 | A, B, ∅ → 3가지 |
| 하의 | 3 | X, Y, Z, ∅ → 4가지 |

**전체 조합**: 3 × 4 = 12

| 상의 | 하의 | 유효? |
|------|------|-------|
| A | X | ✅ |
| A | Y | ✅ |
| A | Z | ✅ |
| A | ∅ | ✅ (상의만) |
| B | X | ✅ |
| B | Y | ✅ |
| B | Z | ✅ |
| B | ∅ | ✅ (상의만) |
| ∅ | X | ✅ (하의만) |
| ∅ | Y | ✅ (하의만) |
| ∅ | Z | ✅ (하의만) |
| ∅ | ∅ | ❌ (아무것도 안 입음) |

**최종 답**: 12 - 1 = **11가지**
