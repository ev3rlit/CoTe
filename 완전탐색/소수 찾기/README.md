# 소수 찾기

#완전탐색 #알고리즘 #코딩테스트

# 문제 난이도 중

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| numbers 길이 | 1 ~ 7 | 최대 7자리 숫자 조각 |
| numbers 구성 | 0~9 숫자만 | 각 문자가 숫자 하나를 의미 |
| 시간 제한 | - | 통상 1초 가정 |
| 메모리 제한 | - | 특별한 제약 없음 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

**순열 개수 분석**:
- N자리 숫자 조각으로 만들 수 있는 모든 순열의 개수
- N=7일 때: 1P1 + 2P2 + ... + 7P7 = 7×7! 미만 ≈ 35,280개 (최악)
- 실제로는 각 길이별 순열의 합: Σ(k=1 to N) P(N,k)

| N | 순열 개수 (최대) | 가능 여부 |
|---|-----------------|----------|
| 7 | ~13,699 | ✅ 충분히 여유로움 |

**소수 판별**:
- 가장 큰 수: 9,999,999 (7자리)
- 소수 판별: O(√M) ≈ 3,162회

**전체 복잡도**: O(N! × √M) ≈ 13,699 × 3,162 ≈ 4,300만 연산 → ✅ 통과

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | 모든 경우 생성 | 완전탐색 (순열) |
| 순서가 중요한가 | 예 (17 ≠ 71) | 순열(Permutation) 사용 |
| 중복 처리 필요 | 예 (11 = 011) | Set으로 중복 제거 |
| 조건 검증 | 소수인지 판별 | 소수 판별 함수 필요 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 완전탐색 (순열 생성) + 소수 판별

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 숫자 조각을 "조합"이 아니라 "순서가 있는 배열"로 만들어야 함
   - 같은 숫자를 다른 순서로 배치하면 다른 수가 됨 (17 ≠ 71)
   - 순열(Permutation)로 모든 경우 생성이 필수

2. **제약 조건 충족**
   - 시간 복잡도: O(N! × √M) → 최대 4,300만 연산 (✅ 통과)
   - 공간 복잡도: O(N!) → Set에 최대 ~13,699개 저장 (✅ 통과)

3. **핵심 인사이트**
   - Python의 `itertools.permutations`로 모든 길이의 순열 생성
   - 문자열을 정수로 변환하여 중복 제거 (011 → 11)
   - 에라토스테네스 체는 과할 수 있음 (직접 소수 판별이 더 간단)

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 에라토스테네스 체 | O(M log log M) | M=9,999,999 범위 전체 체를 만들면 메모리 과다 |
| 조합(Combination) | O(2^N) | 순서가 중요하므로 조합은 적합하지 않음 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "숫자 조각", "만들 수 있는 모든 수", "순서", "순열"
- **문제 유형**: 순열 기반 완전탐색 + 조건 검증
- **주의사항**:
    - 011과 11은 같은 수 → int 변환으로 중복 제거
    - 0이나 1은 소수가 아님 → 예외 처리 필요
    - 같은 숫자가 여러 개 있을 수 있음 (예: "011")

---

## 2. 🧠 자연어 실행 흐름

1. **입력 파싱**: 문자열 `numbers`를 리스트로 변환 (예: "17" → ['1', '7'])
2. **순열 생성**: 길이 1부터 N까지의 모든 순열 생성
   - 길이 1: ['1'], ['7']
   - 길이 2: ['1', '7'], ['7', '1']
3. **정수 변환**: 각 순열을 문자열로 합친 뒤 정수로 변환 (예: ['1', '7'] → 17)
4. **중복 제거**: Set에 저장하여 중복 제거 (011 → 11)
5. **소수 판별**: Set에 있는 각 수가 소수인지 판별
   - 2 미만이면 소수 아님
   - 2부터 √N까지 나누어 떨어지면 소수 아님
6. **개수 반환**: 소수인 것의 개수를 반환

---

## 3. 💻 Code Implementation

(언어: Python)
```python
from itertools import permutations

def solution(numbers):
    # 1. 가능한 모든 숫자 조합 생성 (Set으로 중복 제거)
    candidates = set()
    
    # 2. 길이 1부터 전체 길이까지 모든 순열 생성
    for length in range(1, len(numbers) + 1):
        for perm in permutations(numbers, length):
            # 순열을 문자열로 합친 뒤 정수 변환 (011 → 11)
            num = int(''.join(perm))
            candidates.add(num)
    
    # 3. 소수 판별 함수
    def is_prime(n):
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        # 3부터 √n까지 홀수만 검사
        for i in range(3, int(n ** 0.5) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    # 4. 소수 개수 세기
    count = 0
    for num in candidates:
        if is_prime(num):
            count += 1
    
    return count
```

**복잡도 분석**
- 시간: O(N! × √M) — N=7, M=9,999,999일 때 약 4,300만 연산
- 공간: O(N!) — 최대 약 13,699개의 후보 저장

---

# 평가

## 개선할 점
- **중복 제거 타이밍**: 현재 `candidates`를 리스트로 만든 후 `set()`으로 변환하는데, 처음부터 `set`을 사용하면 메모리와 시간을 절약할 수 있습니다. (`candidates = set()` → `candidates.add(...)`)
- **`concat_number` 함수**: 직접 구현한 숫자 합치기 로직은 좋은 시도지만, `int(''.join(map(str, numbers)))`가 더 Pythonic하고 간결합니다. 다만 현재 방식이 문자열 생성 오버헤드가 없어 약간 더 빠를 수 있습니다.
- **소수 판별 최적화**: `isPrime`에서 2로 먼저 나누어 떨어지는지 확인하고, 3부터 홀수만 검사하면 반복 횟수를 절반으로 줄일 수 있습니다.
- **함수명 컨벤션**: Python에서는 `is_prime`(snake_case)이 PEP 8 권장 스타일입니다.

## 잘한 점
- **단계별 주석**: 코드 상단에 1~4 단계로 흐름을 명시하여 가독성이 좋습니다.
- **별도 함수 분리**: `isPrime`, `concat_number`를 분리하여 코드의 역할이 명확합니다.
- **정수 변환으로 중복 처리**: `int` 변환을 통해 "011" → 11로 자연스럽게 중복을 처리했습니다.
- **itertools 활용**: `permutations`을 적절히 사용하여 순열 생성을 간결하게 처리했습니다.

## 다른 응용 방안
- **암호 해독**: 주어진 문자로 만들 수 있는 모든 조합 생성
- **단어 애너그램**: 글자 조합으로 가능한 단어 찾기
- **자물쇠 조합**: N자리 비밀번호의 모든 경우의 수 탐색
- **게임 AI**: 가능한 모든 수(手) 탐색 후 최적 선택

## 추천 문제
- **백준 1759: 암호 만들기** — 조합 + 조건 검증
- **백준 10974: 모든 순열** — 순열 생성 기초
- **프로그래머스: 피로도** — 순열 기반 완전탐색
- **백준 15649~15652: N과 M 시리즈** — 순열/조합 다양한 변형

## 종합 평가
문제의 핵심인 "순열 생성 → 중복 제거 → 조건 검증" 패턴을 정확히 파악하고 구현했습니다.
`concat_number` 함수를 직접 구현한 것은 저수준 연산에 대한 이해도를 보여주는 좋은 시도입니다.
다만 실제 코딩 테스트에서는 `set`을 처음부터 사용하여 불필요한 리스트 변환을 피하고, 
소수 판별 시 짝수 검사를 먼저 하는 최적화를 습관화하면 더 안정적인 풀이가 가능합니다.
