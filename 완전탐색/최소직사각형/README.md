# 최소직사각형

#완전탐색 #알고리즘 #코딩테스트

# 문제 난이도 하

## 1. 📊 객관적 분석 및 근거

**제약 조건**
- `sizes`의 길이: 1 ~ 10,000
- `w`, `h`: 1 ~ 1,000
- 시간 제한: 통상 1초 (약 10^8 연산)
- 메모리 제한: 통상적인 수준

**시간 복잡도 역산**
- N = 10,000 이므로 O(N^2)은 1억에 근접하여 위험할 수 있으나, O(N) 또는 O(N log N)은 충분함.
- 로직이 매우 단순하므로 O(N)으로 해결 가능.

**알고리즘 선택**
- **선택**: 그리디 (Greedy) / 직관적 완전탐색
- **근거**: 명함을 회전시켜 가장 효율적인 수납 형태를 찾아야 함. 두 변 중 긴 것을 한쪽(가로)으로 몰아넣고, 짧은 것을 다른 쪽(세로)으로 몰아넣으면 가로의 최댓값과 세로의 최댓값의 곱이 최소 넓이가 됨이 수학적으로 자명함.

---

## 2. 🧠 자연어 실행 흐름

1. 모든 명함을 순회하며 확인한다.
2. 각 명함의 가로(`w`), 세로(`h`) 길이를 비교한다.
3. 둘 중 더 긴 값을 `가로_후보`로, 더 짧은 값을 `세로_후보`로 정렬한다 (명함을 눕히는 과정).
4. 모든 명함의 `가로_후보`들 중 가장 큰 값을 찾는다 (`max_w`).
5. 모든 명함의 `세로_후보`들 중 가장 큰 값을 찾는다 (`max_h`).
6. `max_w`와 `max_h`를 곱하여 결과를 반환한다.

---

## 3. 💻 Code Implementation

(언어: Python)
```python
def solution(sizes):
    # max_w: 가로(긴 쪽) 길이 중 최댓값
    # max_h: 세로(짧은 쪽) 길이 중 최댓값
    
    max_w = 0
    max_h = 0
    
    for w, h in sizes:
        # 1. 각 명함을 회전시켜 긴 쪽을 가로(w_cand), 짧은 쪽을 세로(h_cand)로 둠
        #    이렇게 하면 모든 명함이 같은 방향으로 정렬됨
        w_cand = max(w, h)
        h_cand = min(w, h)
        
        # 2. 가장 큰 지갑을 만들어야 하므로, 각 방향의 최댓값을 갱신
        if w_cand > max_w:
            max_w = w_cand
            
        if h_cand > max_h:
            max_h = h_cand
            
    # 3. 최종 지갑 크기 반환
    return max_w * max_h
```

**Pythonic Code**
```python
def solution(sizes):
    # 모든 명함에 대해 max(w, h) 중 최댓값 * min(w, h) 중 최댓값
    return max(max(x) for x in sizes) * max(min(x) for x in sizes)
```

**복잡도 분석**
- 시간: O(N) - sizes 배열을 한 번 순회
- 공간: O(1) - 추가 메모리 거의 없음
```

---

# 평가

## 개선할 점
- **주석에서 "지갑"**: README와 solution.py 주석에서 "지갑"이라는 표현이 있는데, 문제는 "명함 지갑"이므로 맞지만 "최소 직사각형"이 더 명확합니다.
- **제너레이터 중복 순회**: `solution.py`에서 `max((max(size) for size in sizes)) * max((min(size) for size in sizes))`는 sizes를 2번 순회합니다. N=10,000 수준에선 문제없지만, 한 번 순회로 처리하면 더 효율적입니다.

## 잘한 점
- **핵심 인사이트 파악**: "긴 쪽을 가로, 짧은 쪽을 세로로 통일"이라는 문제의 본질을 정확히 이해했습니다.
- **한 줄 Pythonic 코드**: `max(max(x) for x in sizes) * max(min(x) for x in sizes)` — 제너레이터 표현식으로 간결하게 구현했습니다.
- **명확한 사고 흐름 주석**: solution.py 상단의 4줄 주석이 문제 접근 과정을 잘 보여줍니다.
- **두 가지 버전 제시**: README에 명시적 반복문 버전과 Pythonic 버전을 모두 제시하여 비교 가능합니다.

## 다른 응용 방안
- **컨테이너 패킹**: 물건을 회전시켜 상자에 담는 최적화
- **이미지 리사이징**: 여러 이미지를 같은 비율로 정렬
- **화면 레이아웃**: UI 컴포넌트의 최소 공간 계산

## 추천 문제
- **프로그래머스: 카펫** — 넓이/직사각형 관련 완전탐색
- **백준 1051: 숫자 정사각형** — 직사각형 조건 탐색
- **프로그래머스: 멀쩡한 사각형** — 수학적 직사각형 문제

## 종합 평가
"명함을 회전할 수 있다"는 조건에서 **긴 쪽을 한 방향으로 통일**한다는 핵심 아이디어를 정확히 파악했습니다.
O(N) 복잡도로 최적 해결이 가능한 문제인데, 한 줄로 간결하게 구현한 점이 인상적입니다.
사실 이 문제는 "완전탐색"보다는 **그리디/수학적 관찰** 문제에 가깝습니다.
문제 태그에 "완전탐색"이 있지만, 실제 풀이는 각 명함에 대해 독립적인 판단(회전 여부)만 하면 되므로 탐색이 필요 없습니다.
```
