# 최소직사각형

#완전탐색 #알고리즘 #코딩테스트

# 문제 난이도 하

## 1. 📊 객관적 분석 및 근거

**제약 조건**
- `sizes`의 길이: 1 ~ 10,000
- `w`, `h`: 1 ~ 1,000
- 시간 제한: 통상 1초 (약 10^8 연산)
- 메모리 제한: 통상적인 수준

**시간 복잡도 역산**
- N = 10,000 이므로 O(N^2)은 1억에 근접하여 위험할 수 있으나, O(N) 또는 O(N log N)은 충분함.
- 로직이 매우 단순하므로 O(N)으로 해결 가능.

**알고리즘 선택**
- **선택**: 그리디 (Greedy) / 직관적 완전탐색
- **근거**: 명함을 회전시켜 가장 효율적인 수납 형태를 찾아야 함. 두 변 중 긴 것을 한쪽(가로)으로 몰아넣고, 짧은 것을 다른 쪽(세로)으로 몰아넣으면 가로의 최댓값과 세로의 최댓값의 곱이 최소 넓이가 됨이 수학적으로 자명함.

---

## 2. 🧠 자연어 실행 흐름

1. 모든 명함을 순회하며 확인한다.
2. 각 명함의 가로(`w`), 세로(`h`) 길이를 비교한다.
3. 둘 중 더 긴 값을 `가로_후보`로, 더 짧은 값을 `세로_후보`로 정렬한다 (명함을 눕히는 과정).
4. 모든 명함의 `가로_후보`들 중 가장 큰 값을 찾는다 (`max_w`).
5. 모든 명함의 `세로_후보`들 중 가장 큰 값을 찾는다 (`max_h`).
6. `max_w`와 `max_h`를 곱하여 결과를 반환한다.

---

## 3. 💻 Code Implementation

(언어: Python)
```python
def solution(sizes):
    # max_w: 가로(긴 쪽) 길이 중 최댓값
    # max_h: 세로(짧은 쪽) 길이 중 최댓값
    
    max_w = 0
    max_h = 0
    
    for w, h in sizes:
        # 1. 각 명함을 회전시켜 긴 쪽을 가로(w_cand), 짧은 쪽을 세로(h_cand)로 둠
        #    이렇게 하면 모든 명함이 같은 방향으로 정렬됨
        w_cand = max(w, h)
        h_cand = min(w, h)
        
        # 2. 가장 큰 지갑을 만들어야 하므로, 각 방향의 최댓값을 갱신
        if w_cand > max_w:
            max_w = w_cand
            
        if h_cand > max_h:
            max_h = h_cand
            
    # 3. 최종 지갑 크기 반환
    return max_w * max_h
```

**Pythonic Code**
```python
def solution(sizes):
    # 모든 명함에 대해 max(w, h) 중 최댓값 * min(w, h) 중 최댓값
    return max(max(x) for x in sizes) * max(min(x) for x in sizes)
```

**복잡도 분석**
- 시간: O(N) - sizes 배열을 한 번 순회
- 공간: O(1) - 추가 메모리 거의 없음
```
