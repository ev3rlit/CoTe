# 정수 삼각형

#DP #동적계획법 #2차원DP #코딩테스트 #프로그래머스

## 문제 난이도: 중 (Lv.3)

> **문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/43105

---

## 문제 요약

삼각형의 꼭대기에서 바닥까지 이동하며 **거쳐간 숫자의 합이 최대**가 되는 경로를 찾아라.

**이동 규칙**: 아래 칸으로 이동할 때 **대각선 왼쪽 또는 오른쪽**으로만 이동 가능

```
       7
      3 8
     8 1 0
    2 7 4 4
   4 5 2 6 5
```

**예시**: 7 → 3 → 8 → 7 → 5 = **30** (최대)

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| 삼각형 높이 (N) | 1~500 | 행의 개수 |
| 각 숫자 | 0~9,999 | 합산 시 int 범위 내 |
| 총 원소 수 | N*(N+1)/2 | 최대 약 125,000개 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=500일 때 |
|--------|----------|
| O(N²) | 250,000 ✅ |
| O(N² × N) = O(N³) | 125,000,000 ⚠️ |

**이 문제의 경우**:
- 총 원소 수 = N*(N+1)/2 ≈ 125,000 (N=500)
- 각 원소를 한 번씩 방문 → **O(N²) 가능**
- **결론**: O(N²) 알고리즘으로 충분

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **최댓값** (최대 경로 합) | DP 또는 그리디 |
| 순서가 중요한가 | 위→아래 고정 | 순차적 처리 |
| 부분 문제로 나눌 수 있는가 | **YES!** - (i,j)까지의 최대합 = 위에서 온 값 + 현재값 | **DP 적합** |
| 탐욕적 선택이 최적인가 | **NO** - 당장 큰 수가 최종 최대 아닐 수 있음 | 그리디 불가 |

**그리디가 안 되는 이유**:
```
    7
   3 8    ← 8이 더 크지만
  8 1 0   ← 3→8 경로가 8→1 보다 나음
```

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: Bottom-Up DP (2차원)

**핵심 아이디어**:
```
dp[i][j] = "(i, j) 위치까지 도달했을 때 경로 합의 최댓값"
```

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - (i, j) 위치에 도달하는 방법은 **2가지**뿐:
     - 위-왼쪽 `(i-1, j-1)`에서 오거나
     - 위-오른쪽 `(i-1, j)`에서 오거나
   - 이 **분할 구조**가 DP의 핵심

2. **점화식**:
   ```
   dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]
   ```

3. **제약 조건 충족**
   - 시간 복잡도: O(N²) → N=500일 때 약 125,000회 연산 ✅
   - 공간 복잡도: O(N²) → 약 1MB 이하 ✅ (또는 O(N)으로 최적화 가능)

4. **핵심 인사이트**
   - **최적 부분 구조**: 최대 경로는 이전 단계의 최대 경로로부터 온다
   - **중복 부분 문제**: 같은 위치에 여러 경로로 도달 가능 → 메모이제이션 효과

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 완전탐색 (DFS) | O(2^N) | N=500 → 2^500 불가능 |
| 그리디 | O(N) | 반례 존재 (당장 큰 게 최종 최대 아님) |
| BFS | O(N²) | 가능하지만 DP가 더 직관적 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "최대/최소 경로", "위에서 아래로", "왼쪽/오른쪽 선택"
- **문제 유형**: 격자/삼각형에서 경로 최적화
- **주의사항**: 
  - 경계 조건 (맨 왼쪽/오른쪽은 선택지가 하나)
  - 인덱스 범위 체크

---

## 2. 🧠 자연어 실행 흐름

### 방법 1: Top-Down (위→아래)

1. **초기화**: `dp[0][0] = triangle[0][0]` (꼭대기)

2. **행 순회** (i = 1 ~ N-1):
   - 각 위치 (i, j)에 대해:
     - **맨 왼쪽 (j=0)**: 위-오른쪽에서만 올 수 있음
       - `dp[i][0] = dp[i-1][0] + triangle[i][0]`
     - **맨 오른쪽 (j=i)**: 위-왼쪽에서만 올 수 있음
       - `dp[i][i] = dp[i-1][i-1] + triangle[i][i]`
     - **중간**: 두 방향 중 큰 값 선택
       - `dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]`

3. **결과**: 마지막 행에서 최댓값 반환
   - `return max(dp[N-1])`

### 방법 2: Bottom-Up (아래→위) - 더 간단!

1. **삼각형 복사** (또는 원본 수정): `dp = triangle` (깊은 복사)

2. **아래에서 위로 순회** (i = N-2 ~ 0):
   - 각 위치 (i, j)에 대해:
     - `dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])`
   - 즉, **아래 두 자식 중 큰 값을 현재에 더함**

3. **결과**: 꼭대기 값 반환
   - `return dp[0][0]`

**이 방법이 더 간단한 이유**: 경계 조건 처리가 필요 없음!

---

## 3. 💻 Code Implementation

### 풀이 1: Top-Down DP

```python
def solution(triangle):
    n = len(triangle)
    
    # dp[i][j] = (i,j)까지의 최대 경로 합
    dp = [[0] * len(row) for row in triangle]
    dp[0][0] = triangle[0][0]
    
    for i in range(1, n):
        for j in range(i + 1):
            # 맨 왼쪽: 위-오른쪽에서만 올 수 있음
            if j == 0:
                dp[i][j] = dp[i-1][j] + triangle[i][j]
            # 맨 오른쪽: 위-왼쪽에서만 올 수 있음
            elif j == i:
                dp[i][j] = dp[i-1][j-1] + triangle[i][j]
            # 중간: 두 방향 중 큰 값
            else:
                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]
    
    return max(dp[n-1])
```

### 풀이 2: Bottom-Up DP (더 간결)

```python
def solution(triangle):
    # 아래에서 위로 올라가면서 최댓값 누적
    # 원본을 변경하지 않으려면 deepcopy 사용
    dp = [row[:] for row in triangle]  # 깊은 복사
    
    for i in range(len(dp) - 2, -1, -1):  # 아래에서 두 번째 행부터
        for j in range(i + 1):
            # 아래 두 자식 중 큰 값을 선택해서 현재에 더함
            dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])
    
    # 꼭대기에 최대 경로 합이 저장됨
    return dp[0][0]
```

### 풀이 3: 공간 최적화 (O(N))

```python
def solution(triangle):
    # 마지막 행을 dp 배열로 사용
    dp = triangle[-1][:]
    
    for i in range(len(triangle) - 2, -1, -1):
        for j in range(i + 1):
            dp[j] = triangle[i][j] + max(dp[j], dp[j+1])
    
    return dp[0]
```

**복잡도 분석**
- **시간**: O(N²) - 모든 원소 한 번씩 방문
- **공간**: 
  - 풀이 1, 2: O(N²)
  - 풀이 3: O(N)

---

## 4. 🔍 핵심 포인트 정리

### 왜 Bottom-Up이 더 간단한가?
- **Top-Down**: 경계 조건(맨 왼쪽/오른쪽) 분기 처리 필요
- **Bottom-Up**: 각 위치에서 항상 두 자식이 존재 → 분기 없음

### 점화식 비교

| 방향 | 점화식 | 최종 답 |
|------|--------|---------|
| Top-Down | `dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]` | `max(dp[N-1])` |
| Bottom-Up | `dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])` | `dp[0][0]` |

### 이 문제의 교훈
> **"같은 문제도 방향을 바꾸면 더 쉬워질 수 있다"**

Top-Down과 Bottom-Up 중 **경계 조건이 덜 복잡한 방향**을 선택하면 코드가 간결해집니다.

---

# 평가

## 🔍 주석에서 읽은 사고 과정

코드의 주석에서 **문제 해결 과정**이 잘 드러납니다:

```python
# 완전 이진트리는 아니지만 트리임
# ...
# 결론  현재 높이 h 기준 i노드에서 자식으로 가려면? i+h, i+h+1 이동
```

**1D 배열 인덱싱** 방식을 시도한 흔적이 보입니다. 이건 좋은 시도이지만:
- 삼각형을 1D로 펼치면: `[7, 3, 8, 8, 1, 0, 2, 7, 4, 4]`
- 높이 h, 위치 i에서 자식: `i + h`, `i + h + 1` (정확!)
- 하지만 **2D 좌표가 더 직관적**이라는 결론에 도달 ✅

```python
# 높이를 기준으로 노드를 생각하지 않고 각 노드별 좌표를 이용하는
# 방식이 더 깔끔하고 직관적임  d[i][j] ->  (y,x)
```

**스스로 더 나은 방법을 찾아가는 과정**이 주석에 기록되어 있어 좋습니다.

---

## 개선할 점

### 1. 깊은 복사 대신 원본 수정 고려
```python
# 현재
dp = [row[:] for row in triangle]

# 대안: 원본을 수정해도 되는 경우 (문제에서 triangle 재사용 없음)
# 메모리 절약 가능
for i in range(len(triangle) - 2, -1, -1):
    for j in range(i + 1):
        triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1])
return triangle[0][0]
```

### 2. 공간 최적화 버전도 연습 권장
```python
# O(N) 공간 버전
dp = triangle[-1][:]
for i in range(len(triangle) - 2, -1, -1):
    for j in range(i + 1):
        dp[j] = triangle[i][j] + max(dp[j], dp[j+1])
return dp[0]
```

이 버전은 **dp 배열을 한 줄만 유지**합니다. 면접에서 "공간 최적화해보세요"라고 하면 유용합니다.

### 3. 주석 정리
최종 코드에는 **시도 과정 주석**과 **설명 주석**을 분리하면 좋습니다:
- 시도 과정 → 별도 메모 또는 제거
- 핵심 설명만 코드에 남기기

---

## 잘한 점

### 1. Bottom-Up 선택
```python
# dp[h] = 현재 높이 h 까지 거쳐온 노드들의 집합
# 이번문제는 배열 순회로 bottom up이 더 쉬울거같음
```
**경계 조건 없이 깔끔하게 풀리는 방향**을 선택한 판단이 좋습니다.

### 2. 깊은 복사 사용
```python
dp = [row[:] for row in triangle]
```
원본 훼손을 방지하는 **안전한 코딩 습관** ✅

### 3. 핵심 로직 5줄
```python
for i in range(len(dp)-2, -1, -1):
    for j in range(i+1):
        dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])
return dp[0][0]
```
군더더기 없이 **점화식을 그대로 코드화** ✅

---

## 다른 응용 방안

이 **격자/삼각형 DP** 패턴은 다음 상황에서 활용 가능:

| 상황 | 예시 |
|------|------|
| **경로 최적화** | 최소/최대 비용 경로 |
| **격자 이동** | 등굣길, 미로 탈출 경로 수 |
| **파스칼 삼각형** | 조합론 문제 |
| **광산 채굴** | 금광 문제 (왼쪽 위/위/오른쪽 위에서 이동) |

---

## 추천 문제

| 문제 | 유형 | 포인트 |
|------|------|--------|
| 프로그래머스 - 등굣길 | 격자 DP (경로 수) | 장애물 처리 추가 |
| 프로그래머스 - 도둑질 | 원형 DP | 시작/끝 연결 고려 |
| 백준 1932 - 정수 삼각형 | 동일 문제 | Top-Down으로도 풀어보기 |
| 백준 1149 - RGB거리 | 선택 제약 DP | 연속 선택 불가 조건 |

---

## 종합 평가

**핵심 알고리즘을 정확히 이해하고 깔끔하게 구현했습니다.**

특히 인상적인 점은 주석에 남긴 **사고 과정**입니다:
- 1D 인덱싱 시도 → 복잡함 인지 → 2D 좌표로 전환
- 완전탐색 고려 → DP로 최적화
- Top-Down vs Bottom-Up 중 더 간단한 Bottom-Up 선택

이런 **"왜 이 방법을 선택했는가?"**를 기록하는 습관은:
1. 나중에 복습할 때 도움
2. 비슷한 문제에서 더 빠른 판단 가능
3. 면접에서 "왜 이렇게 풀었나요?" 질문에 대비

**다음 단계 제안**:
1. Top-Down 버전도 직접 구현해보기 (경계 조건 처리 연습)
2. 공간 최적화 O(N) 버전 작성해보기
3. "등굣길" 문제로 장애물이 있는 격자 DP 연습
