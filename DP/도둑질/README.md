# 도둑질

#DP #동적계획법 #원형배열 #HouseRobber #코딩테스트 #프로그래머스

## 문제 난이도: 상 (Lv.4)

> **문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/42897

---

## 문제 요약
 
- 마을의 집들이 **원형으로** 배치되어 있음
- **인접한 두 집을 털면** 경보가 울림
- 도둑이 훔칠 수 있는 돈의 **최댓값**을 구하라

```
핵심 포인트:
- 일반적인 House Robber 문제의 변형
- 첫 번째 집과 마지막 집이 "인접" (원형 구조)
```

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| 집 개수 (N) | 3 ~ 1,000,000 | 대용량 데이터, O(N) 또는 O(N log N) 필요 |
| 돈의 범위 | 0 ~ 1,000 | 오버플로우 걱정 없음 (최대 10^9) |
| 배열 형태 | **원형** | 첫 번째와 마지막 집이 인접 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N = 1,000,000일 때 |
|--------|-------------------|
| O(N) | 1,000,000 ✅ |
| O(N log N) | 20,000,000 ✅ |
| O(N²) | 10^12 ❌ |

**이 문제의 경우**:
- N = 최대 1,000,000
- **결론**: O(N) 알고리즘 필요

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **최댓값** (최적화) | DP 또는 그리디 |
| 순서가 중요한가 | **YES** - 집 순서 고정 | 순차 DP 가능 |
| 부분 문제로 나눌 수 있는가 | **YES** - i번째 집까지의 최대 | **선형 DP** |
| 탐욕적 선택이 최적인가 | **NO** - 현재 선택이 미래에 영향 | 그리디 불가 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 선형 DP × 2회 (Case 분리)

**핵심 아이디어**:
```
원형 배열의 특수성:
- 첫 번째 집을 털면 → 마지막 집 못 털음
- 첫 번째 집을 안 털면 → 마지막 집 털 수 있음

해결책:
1. 첫 번째 집 포함, 마지막 집 제외: money[0:n-1]
2. 첫 번째 집 제외, 마지막 집 포함: money[1:n]
→ 두 경우 중 max 선택
```

**상태 정의** (일반 House Robber):
```
dp[i] = i번째 집까지 고려했을 때 훔칠 수 있는 최댓값

점화식:
dp[i] = max(dp[i-1], dp[i-2] + money[i])
       ↑ 이 집 안 털음   ↑ 이 집 털음
```

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 인접 불가 조건 → i번째 선택이 i-1번째에만 영향
   - 원형 → 케이스 분리로 선형 문제 2개로 변환

2. **제약 조건 충족**
   - 시간 복잡도: O(N) × 2 = O(N) ✅
   - 공간 복잡도: O(1) (변수 2개로 최적화 가능) ✅

3. **핵심 인사이트**
   - **원형 배열 DP의 공식**: 첫 번째/마지막 원소의 동시 선택 불가
   - 케이스를 "첫 번째 포함 vs 제외"로 나누면 선형 문제로 환원

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 완전탐색 (모든 조합) | O(2^N) | N=10^6이면 시간 초과 |
| 그리디 (가장 큰 것부터) | O(N log N) | 반례 존재 - 2번째로 큰 집이 더 나은 경우 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "인접 불가", "원형 배열", "최댓값/최솟값"
- **문제 유형**: 
  - House Robber I/II/III (LeetCode 198, 213, 337)
  - 포도주 시식 (백준 2156)
  - 스티커 (백준 9465)
- **주의사항**: 
  - 원형일 때 반드시 케이스 분리!
  - 공간 최적화 시 변수 스왑 순서 주의

---

## 2. 🧠 자연어 실행 흐름

1. **입력 확인**
   - 집 개수 n과 각 집의 돈 money 배열 확인
   - 원형 배열이므로 money[0]과 money[n-1]은 인접

2. **케이스 분리**
   - **Case 1**: 첫 번째 집을 털 가능성 포함 → money[0:n-1] 범위로 DP
   - **Case 2**: 마지막 집을 털 가능성 포함 → money[1:n] 범위로 DP

3. **각 케이스에서 선형 DP 수행**
   - prev2 = 2칸 전까지의 최댓값
   - prev1 = 1칸 전까지의 최댓값
   - 현재 = max(prev1, prev2 + 현재 집의 돈)
   - prev2, prev1 갱신

4. **두 케이스 중 최댓값 반환**

---

## 3. 💻 Code Implementation

```python
def solution(money):
    n = len(money)
    
    # 예외 처리: 집이 3개면 가장 큰 1개만 선택 가능
    if n == 3:
        return max(money)
    
    def rob_linear(arr):
        """선형 배열에서 인접하지 않은 집들의 최대 합"""
        prev2, prev1 = 0, 0
        for m in arr:
            prev2, prev1 = prev1, max(prev1, prev2 + m)
        return prev1
    
    # Case 1: 첫 번째 집 포함 가능 → 마지막 집 제외
    case1 = rob_linear(money[:-1])
    
    # Case 2: 마지막 집 포함 가능 → 첫 번째 집 제외
    case2 = rob_linear(money[1:])
    
    return max(case1, case2)
```

**복잡도 분석**
- **시간**: O(N) - 배열을 2번 순회
- **공간**: O(1) - 변수 2개만 사용 (슬라이싱 시 O(N) 될 수 있음, 주의)

### 변형: DP 배열 사용 버전

공간 최적화를 하지 않고 dp 배열을 그대로 사용하는 버전입니다.  
이해가 더 직관적이며, 디버깅이 쉬운 장점이 있습니다.

```python
def solution(money):
    n = len(money)
    
    if n == 3:
        return max(money)
    
    def rob_linear(start, end):
        """dp 배열을 사용한 선형 DP"""
        length = end - start + 1
        dp = [0] * length
        
        # Base case
        dp[0] = money[start]
        if length > 1:
            dp[1] = max(money[start], money[start + 1])
        
        # 점화식 적용
        for i in range(2, length):
            dp[i] = max(dp[i-1], dp[i-2] + money[start + i])
        
        return dp[-1]
    
    # Case 1: 첫 번째 집 포함 가능, 마지막 집 제외
    case1 = rob_linear(0, n - 2)
    
    # Case 2: 첫 번째 집 제외, 마지막 집 포함
    case2 = rob_linear(1, n - 1)
    
    return max(case1, case2)
```

**복잡도 분석 (배열 버전)**
- **시간**: O(N)
- **공간**: O(N) - dp 배열 사용

> **💡 언제 어떤 버전을 쓸까?**
> - **연습/학습 중**: 배열 버전으로 dp 값의 변화를 확인하며 디버깅
> - **실전 코테**: 변수 2개 버전으로 공간 최적화

---

## 4. 🔍 핵심 포인트 정리

### ⚠️ 가장 중요한 인사이트

> **원형 배열 DP = 케이스 분리!**

```
첫 번째 집 O, 마지막 집 X → money[0:n-1]
첫 번째 집 X, 마지막 집 O → money[1:n]
```

이 패턴은 다음 변형에서도 동일:
- 원형 스티커
- 원형 징검다리
- 모든 "원형 + 인접 불가" 문제

### 공간 최적화 팁

```python
# 배열 슬라이싱 대신 인덱스로 처리하면 O(1) 공간 가능
def rob_range(money, start, end):
    prev2, prev1 = 0, 0
    for i in range(start, end):
        prev2, prev1 = prev1, max(prev1, prev2 + money[i])
    return prev1

case1 = rob_range(money, 0, n-1)
case2 = rob_range(money, 1, n)
```

### 비슷한 문제들

| 문제 | 핵심 | 차이점 |
|------|------|--------|
| House Robber I | 선형 배열 | 케이스 분리 불필요 |
| House Robber III | 트리 구조 | 트리 DP로 확장 |
| 포도주 시식 | 연속 3개 불가 | 상태가 3개로 확장 |

---

## 5. 💡 회고

(풀이 후 작성)

---

# 평가

## 개선할 점
- `rob_linear` 함수에 docstring이 없음 - 실제 코테에선 불필요하지만 복습용 코드에는 추가 권장
- 슬라이싱 `money[:-1]`, `money[1:]`은 O(N) 공간을 사용 - 대용량 테스트에서 메모리 효율이 떨어질 수 있음

## 잘한 점
- **주석으로 사고 과정을 상세히 기록** (1~6, 14~20번 라인) - prev1, prev2의 변화 과정을 직접 시뮬레이션한 흔적이 좋음
- 핵심 인사이트인 **"원형 = 케이스 분리"**를 정확히 파악하고 주석에 명시
- 공간 최적화(O(1))를 자연스럽게 적용 - 배열 대신 변수 2개로 해결
- `n == 3` 예외 처리를 깔끔하게 분리

## 다른 응용 방안
- **House Robber III (트리)**: 동일 인사이트를 트리 구조로 확장 (부모-자식 인접 불가)
- **포도주 시식 (백준 2156)**: 연속 3개 불가 조건에서 동일한 DP 최적화 기법 적용
- **원형 스티커/징검다리**: 원형 + 인접 불가 패턴의 변형
- **Fibonacci 변형 문제들**: prev1, prev2 패턴은 모든 선형 DP에서 공간 최적화에 활용 가능

## 추천 문제
- **LeetCode 198: House Robber** - 선형 버전, 기본기 확인
- **LeetCode 337: House Robber III** - 트리 DP로 확장
- **백준 2156: 포도주 시식** - 연속 3개 불가 조건
- **백준 9465: 스티커** - 2차원 DP로 확장
- **프로그래머스: 정수 삼각형** - 비슷한 공간 최적화 적용 가능

## 종합 평가

**원형 배열 DP**의 핵심 인사이트를 정확히 이해하고 구현했습니다. 특히 주석에서 `prev1, prev2`의 변화 과정을 직접 시뮬레이션(16~19번 라인)한 것은 **스스로 이해를 검증**하는 좋은 습관입니다.

이 문제는 "원형 → 케이스 분리"라는 패턴만 알면 일반 House Robber 문제로 환원되므로, 핵심은 **패턴 인식 속도**입니다. Lv.4 문제치고는 구현이 간단한 편이며, 동일 패턴이 자주 출제되므로 이 인사이트를 확실히 체화해두면 유사 문제에서 빠르게 접근할 수 있습니다.

다만 슬라이싱 대신 인덱스 범위를 직접 전달하는 방식(`rob_range(money, start, end)`)을 사용하면 공간 복잡도를 O(1)로 완전히 최적화할 수 있으니, 대용량 테스트가 있는 문제에서는 이 방식을 고려해보세요.
