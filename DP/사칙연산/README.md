# 사칙연산

#DP #동적계획법 #구간DP #IntervalDP #코딩테스트 #프로그래머스

## 문제 난이도: 상 (Lv.4)

> **문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/1843

---

## 문제 요약

- 숫자와 연산자(+, -)로 이루어진 수식이 주어짐
- **괄호를 어디에 치느냐**에 따라 결과가 달라짐
- 가능한 모든 연산 순서 중 **최댓값**을 구하라

```
예시: 1 - 3 + 5 - 8
가능한 결과: [-15, -5, -5, 1, 1]
최댓값: 1
```

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| 배열 길이 | 3~201 (홀수) | 숫자 최대 101개, 연산자 최대 100개 |
| 숫자 개수 (N) | 2~101 | **구간 DP 가능** (N² ≈ 10,000) |
| 숫자 범위 | 1~1,000 | 오버플로우 고려 불필요 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=101일 때 |
|--------|------------|
| O(N²) | 10,201 ✅ |
| O(N³) | 1,030,301 ✅ |
| O(2^N) | 2^101 ❌❌❌ |

**이 문제의 경우**:
- 숫자 개수 N = 최대 101
- 가능한 괄호 조합 = **카탈란 수** → 지수적 증가 (완전탐색 불가)
- **결론**: O(N³) 이하의 알고리즘 필요 → **구간 DP**

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **최댓값** (최적화) | DP 또는 그리디 |
| 순서가 중요한가 | **YES** - 괄호 위치에 따라 결과 변화 | 순서 고정, 분할 위치 선택 |
| 부분 문제로 나눌 수 있는가 | **YES!** - 수식을 두 부분으로 분할 | **구간 DP 적합** |
| 탐욕적 선택이 최적인가 | **NO** - 뺄셈 때문에 복잡 | 그리디 불가 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 구간 DP (Interval DP) + 최대/최소 동시 추적

**핵심 아이디어**:
```
수식 "A op B"에서 결과를 최대화하려면?

op가 + 일 때: max(A) + max(B)
op가 - 일 때: max(A) - min(B)  ← 최솟값도 필요!
```

> **핵심 인사이트**: 뺄셈이 있으므로 **최댓값만으로는 부족**하다!
> 최댓값을 구하려면 **최솟값도 함께 추적**해야 한다.

**상태 정의**:
```
dp_max[i][j] = 숫자 i~j 구간에서 만들 수 있는 최댓값
dp_min[i][j] = 숫자 i~j 구간에서 만들 수 있는 최솟값
```

**점화식**:
```
구간 [i, j]를 k번째 연산자로 분할할 때:

if 연산자[k] == '+':
    dp_max[i][j] = max(dp_max[i][k] + dp_max[k+1][j])
    dp_min[i][j] = min(dp_min[i][k] + dp_min[k+1][j])
    
if 연산자[k] == '-':
    dp_max[i][j] = max(dp_max[i][k] - dp_min[k+1][j])  ← 최대 - 최소
    dp_min[i][j] = min(dp_min[i][k] - dp_max[k+1][j])  ← 최소 - 최대
```

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - 수식을 **연산자 위치에서 분할** → 좌/우 부분 문제로 나눔
   - 부분 결과를 합쳐 전체 결과 계산 가능
   - **"어디서 분할할까?"** = 구간 DP의 전형적 패턴

2. **제약 조건 충족**
   - 시간 복잡도: O(N³) → 101³ ≈ 10^6 ✅
   - 공간 복잡도: O(N²) → 101² × 2 ≈ 20,000 ✅

3. **핵심 인사이트**
   - **뺄셈의 특성**: `A - B`를 최대화하려면 `A`는 최대, `B`는 **최소**여야 함
   - 따라서 **최댓값과 최솟값을 동시에** 트래킹해야 함
   - 이 패턴은 "행렬 곱셈 순서", "최적 이진 탐색 트리" 등과 유사

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 완전탐색 (모든 괄호 조합) | O(카탈란(N)) ≈ O(4^N) | N=100이면 시간 초과 |
| 그리디 (- 다음은 최소로) | O(N) | 반례 존재, 최적해 보장 불가 |
| 분할정복 (메모 없이) | O(2^N) | 중복 계산으로 시간 초과 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "수식", "괄호 위치", "연산 순서", "최댓값/최솟값"
- **문제 유형**: 
  - 행렬 곱셈 순서 (Matrix Chain Multiplication)
  - 풍선 터뜨리기 (Burst Balloons)
  - 스톤 게임 변형
- **주의사항**: 
  - 뺄셈/곱셈/나눗셈이 있으면 **최솟값도 추적**
  - 구간의 시작/끝 인덱스 혼동 주의

---

## 2. 🧠 자연어 실행 흐름

1. **입력 파싱**
   - 배열에서 숫자만 추출 → `nums[]`
   - 배열에서 연산자만 추출 → `ops[]`
   - 예: `["1", "-", "3", "+", "5"]` → nums=[1,3,5], ops=['-','+']

2. **DP 테이블 초기화**
   - `dp_max[i][i] = nums[i]` (길이 1 구간은 자기 자신)
   - `dp_min[i][i] = nums[i]`

3. **구간 길이 순으로 채우기** (Bottom-Up)
   - 길이 2, 3, 4, ... 순으로 확장
   - 각 구간 [i, j]에 대해:
     - 모든 분할 위치 k (i ≤ k < j)를 시도
     - 연산자 ops[k]에 따라 최대/최소 계산

4. **결과 반환**
   - `dp_max[0][n-1]` = 전체 구간의 최댓값

---

## 3. 💻 Code Implementation

```python
def solution(arr):
    # 1. 숫자와 연산자 분리
    nums = []
    ops = []
    for i, x in enumerate(arr):
        if i % 2 == 0:
            nums.append(int(x))
        else:
            ops.append(x)
    
    n = len(nums)
    
    # 2. DP 테이블 초기화
    # dp_max[i][j] = 구간 [i, j]의 최댓값
    # dp_min[i][j] = 구간 [i, j]의 최솟값
    INF = float('inf')
    dp_max = [[-INF] * n for _ in range(n)]
    dp_min = [[INF] * n for _ in range(n)]
    
    # Base case: 길이 1 구간
    for i in range(n):
        dp_max[i][i] = nums[i]
        dp_min[i][i] = nums[i]
    
    # 3. 구간 길이 순으로 채우기 (length = 2, 3, ..., n)
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1  # 구간 끝
            
            # 모든 분할 위치 k 시도 (i <= k < j)
            for k in range(i, j):
                op = ops[k]  # k번째 연산자
                
                if op == '+':
                    # 최댓값: 왼쪽 최대 + 오른쪽 최대
                    dp_max[i][j] = max(dp_max[i][j], 
                                       dp_max[i][k] + dp_max[k+1][j])
                    # 최솟값: 왼쪽 최소 + 오른쪽 최소
                    dp_min[i][j] = min(dp_min[i][j], 
                                       dp_min[i][k] + dp_min[k+1][j])
                else:  # op == '-'
                    # 최댓값: 왼쪽 최대 - 오른쪽 최소
                    dp_max[i][j] = max(dp_max[i][j], 
                                       dp_max[i][k] - dp_min[k+1][j])
                    # 최솟값: 왼쪽 최소 - 오른쪽 최대
                    dp_min[i][j] = min(dp_min[i][j], 
                                       dp_min[i][k] - dp_max[k+1][j])
    
    # 4. 전체 구간의 최댓값 반환
    return dp_max[0][n-1]
```

**복잡도 분석**
- **시간**: O(N³) - 구간 O(N²) × 분할점 O(N)
- **공간**: O(N²) - dp_max, dp_min 각각 N×N

---

## 4. 🔍 핵심 포인트 정리

### ⚠️ 가장 중요한 인사이트

> **뺄셈이 있으면 최솟값도 추적해야 한다!**

```
최대 - 최소 = 최대
최소 - 최대 = 최소
```

이 패턴은 다음 문제들에서도 동일하게 적용:
- 곱셈이 있는 경우 (음수 × 음수 = 양수)
- 게임 이론 (상대방은 나를 최소화하려 함)

### 구간 DP의 전형적 구조

```python
# 구간 길이 순으로 확장
for length in range(2, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
        for k in range(i, j):  # 분할점
            # dp[i][j] = 최적(dp[i][k], dp[k+1][j])
```

### 비슷한 문제들

| 문제 | 핵심 | 차이점 |
|------|------|--------|
| 행렬 곱셈 순서 | 곱셈 횟수 최소화 | 최솟값만 추적 |
| Burst Balloons | 터지는 순서 최적화 | 곱셈, 양 끝 처리 |
| 이 문제 | 뺄셈 최댓값 | **최대/최소 동시 추적** |

---

## 5. 💡 회고

(풀이 후 작성)

---

# 평가

## 개선할 점
- `INF = 2**63` 대신 `float('inf')` 사용이 더 Pythonic하고 가독성이 좋음. 현재 코드도 동작하지만 README의 예시 코드와 일관성이 맞지 않음
- 44번 라인의 `# 3.` 주석이 미완성 상태로 남아있어 정리 필요
- 58~59번 라인에 불필요한 공백 라인이 있음 - 코드 정리 습관 들이기

## 잘한 점
- 주석으로 **사고 과정을 상세히 기록**함 (1~19번 라인) - 이 습관은 복습과 면접 설명에 매우 유용
- 핵심 인사이트인 `max(A) - min(B)` 관계를 정확히 파악하고 주석에 명시
- 입력 파싱, DP 초기화, 점화식 적용, 결과 반환의 4단계 구조를 명확히 분리

## 다른 응용 방안
- **행렬 곱셈 순서 (Matrix Chain Multiplication)**: 동일한 구간 DP 구조, 연산만 다름
- **풍선 터뜨리기 (Burst Balloons)**: 구간 DP + 양 끝 경계 처리
- **최적 이진 탐색 트리**: 탐색 비용 최소화에 구간 DP 적용
- **게임 이론 문제**: 상대방은 나를 최소화하려 하므로 min/max 동시 추적 필요

## 추천 문제
- **백준 11066: 파일 합치기** - 구간 DP 기본, 최솟값만 추적
- **백준 11049: 행렬 곱셈 순서** - 구간 DP 응용
- **LeetCode 312: Burst Balloons** - 구간 DP 심화, 경계 처리 학습
- **프로그래머스: 최적의 행렬 곱셈** - 구간 DP 연습

## 종합 평가

정답 코드를 참고했다고 하셨지만, 단순히 복사가 아닌 **사고 흐름을 주석으로 재구성**하며 이해하려 한 점이 좋습니다. 특히 "dp 하나로는 최대값 밖에 못구하기 때문에 dp_max, dp_min 이용"이라는 주석은 이 문제의 핵심을 정확히 짚고 있습니다.

그러나 솔직히 말해, 이 문제는 **정답을 보지 않고 독력(獨力)으로 풀기 매우 어려운 문제**입니다:

1. **최대/최소 동시 추적**이라는 아이디어는 뺄셈의 특성에서 자연스럽게 떠올리기 어려움
2. 구간 DP 자체가 코딩 테스트에서 빈출되지 않아 패턴 인식이 약할 수밖에 없음
3. Lv.4 문제로서 당연히 한 번에 풀 수 있는 난이도가 아님

**다음 단계로 추천하는 학습법**:
- 2~3일 후 README를 다시 읽고, 코드를 보지 않고 백지에서 다시 구현해보기
- 파일 합치기(백준 11066) 등 유사 문제를 정답 없이 먼저 30분 시도해보기
- 막히면 "최대/최소 동시 추적이 필요한가?"를 자문해보는 습관 만들기

정답을 참고한 것 자체는 효율적인 학습 전략입니다. 중요한 것은 **다음에 비슷한 문제를 만났을 때 혼자 힘으로 접근할 수 있는가**이며, 그 역량은 반복 연습으로만 쌓입니다.
