# 등굣길

#DP #동적계획법 #2차원DP #격자DP #코딩테스트 #프로그래머스

## 문제 난이도: 중 (Lv.3)

> **문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/42898

---

## 문제 요약

- **m × n** 격자에서 **집(1,1)**에서 **학교(m,n)**까지 이동
- **오른쪽, 아래쪽**으로만 이동 가능
- **물에 잠긴 지역(puddles)** 은 지나갈 수 없음
- **최단경로의 개수**를 `1,000,000,007`로 나눈 나머지 반환

```
집(1,1) ─────────────────►
    │     ■(물웅덩이)
    │
    ▼              학교(m,n)
```

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| 격자 크기 (m, n) | 1~100 | 최대 100×100 = 10,000 칸 |
| 물웅덩이 개수 | 0~10 | 매우 적음 → 특별 처리 가능 |
| 결과 | mod 10^9+7 | 경로 수가 매우 클 수 있음 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | m=n=100일 때 |
|--------|-------------|
| O(m × n) | 10,000 ✅ |
| O(m × n × k) | 100,000 ✅ (k=10 물웅덩이) |

**이 문제의 경우**:
- 격자 크기 = 100 × 100 = 10,000
- 각 칸을 한 번씩 방문 → **O(m × n) 충분**

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **경로의 개수** (counting) | DP 적합 |
| 순서가 중요한가 | 오른쪽/아래로 고정 | 순차적 처리 |
| 부분 문제로 나눌 수 있는가 | **YES!** - (i,j)까지 경로 수 = 왼쪽에서 온 것 + 위에서 온 것 | **DP 적합** |
| 탐욕적 선택이 최적인가 | 해당 없음 (개수 세기) | 그리디 불가 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 2차원 DP (격자 경로 카운팅)

**핵심 아이디어**:
```
dp[i][j] = "(i, j) 위치까지 도달하는 최단경로의 개수"
```

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - (i, j)에 도달하는 방법은 **2가지**뿐:
     - 왼쪽 `(i, j-1)`에서 오거나
     - 위쪽 `(i-1, j)`에서 오거나
   - 경로 수 = 두 경우의 합

2. **점화식**:
   ```
   dp[i][j] = dp[i-1][j] + dp[i][j-1]  (물웅덩이가 아닌 경우)
   dp[i][j] = 0                        (물웅덩이인 경우)
   ```

3. **제약 조건 충족**
   - 시간 복잡도: O(m × n) → 100×100 = 10,000회 ✅
   - 공간 복잡도: O(m × n) → 약 40KB ✅

4. **핵심 인사이트**
   - **정수 삼각형과 매우 유사**: 합 대신 경로 수 카운팅
   - **장애물 처리**: 물웅덩이 = 0으로 설정

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| DFS 완전탐색 | O(2^(m+n)) | 경로 수가 기하급수적 |
| BFS | O(m × n) | 가능하지만 DP가 더 직관적 |
| 조합론 (nCr) | O(1) | 물웅덩이가 없으면 가능, 있으면 복잡 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "경로의 개수", "오른쪽/아래로만", "격자", "장애물"
- **문제 유형**: 격자 경로 카운팅
- **주의사항**: 
  - **좌표 체계**: 문제에서 (x, y) vs 배열 인덱스 (행, 열) 혼동 주의!
  - **mod 연산**: 덧셈마다 적용해야 오버플로우 방지
  - **물웅덩이 좌표**: (x, y) = (열, 행) 순서일 수 있음!

---

## 2. 🧠 자연어 실행 흐름

1. **DP 테이블 초기화**
   - `(m+1) × (n+1)` 크기의 2D 배열 생성 (1-indexed)
   - 모든 값을 0으로 초기화

2. **물웅덩이 표시**
   - puddles의 각 좌표를 -1 또는 별도 표시
   - **주의**: 문제의 좌표가 (열, 행) 순서인지 확인!

3. **시작점 설정**
   - `dp[1][1] = 1` (집에서 시작하는 경로 1개)

4. **DP 테이블 채우기** (행 우선 순회)
   - 각 (i, j)에 대해:
     - 물웅덩이면: `dp[i][j] = 0` (skip)
     - 아니면: `dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD`

5. **결과 반환**
   - `dp[n][m]` 반환 (또는 좌표 체계에 맞게)

---

## 3. 💻 Code Implementation

```python
def solution(m, n, puddles):
    MOD = 1_000_000_007
    
    # dp[i][j] = (i,j)까지의 최단경로 개수
    # 주의: 문제에서 m=가로(열), n=세로(행)
    # 따라서 dp[행][열] = dp[n][m] 크기로 생성
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    
    # 물웅덩이 표시 (좌표 변환 주의!)
    # puddles는 [x, y] = [열, 행] 형태
    puddle_set = set()
    for x, y in puddles:
        puddle_set.add((y, x))  # (행, 열)로 변환
    
    # 시작점
    dp[1][1] = 1
    
    # 시작점이 물웅덩이인 경우 (문제 조건상 없음)
    if (1, 1) in puddle_set:
        return 0
    
    # DP 테이블 채우기
    for i in range(1, n + 1):      # 행
        for j in range(1, m + 1):  # 열
            if i == 1 and j == 1:
                continue  # 시작점은 이미 설정
            
            if (i, j) in puddle_set:
                dp[i][j] = 0  # 물웅덩이는 지나갈 수 없음
            else:
                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD
    
    return dp[n][m]
```

**복잡도 분석**
- **시간**: O(m × n) - 각 칸 한 번씩 방문
- **공간**: O(m × n) - DP 테이블

---

## 4. 🔍 핵심 포인트 정리

### ⚠️ 가장 흔한 실수: 좌표 혼동

문제에서:
- `m` = 가로 크기 (열의 개수)
- `n` = 세로 크기 (행의 개수)
- `puddles` = `[[x, y], ...]` where x=열, y=행

배열에서:
- `dp[행][열]` = `dp[y][x]`

**따라서 puddles의 좌표를 변환해야 함!**
```python
for x, y in puddles:
    puddle_set.add((y, x))  # (행, 열)로 변환
```

### 정수 삼각형과의 비교

| 항목 | 정수 삼각형 | 등굣길 |
|------|------------|--------|
| 목표 | 최대 합 | 경로 개수 |
| 점화식 | `max(위, 위-왼쪽) + 현재값` | `위 + 왼쪽` |
| 장애물 | 없음 | 물웅덩이 |
| 연산 | max, + | + (카운팅) |
| mod | 없음 | 10^9 + 7 |

### 공간 최적화 (O(m))

```python
def solution(m, n, puddles):
    MOD = 1_000_000_007
    puddle_set = {(y, x) for x, y in puddles}
    
    dp = [0] * (m + 1)
    dp[1] = 1
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if (i, j) in puddle_set:
                dp[j] = 0
            elif i == 1 and j == 1:
                dp[j] = 1
            else:
                dp[j] = (dp[j] + dp[j-1]) % MOD
    
    return dp[m]
```

---

## 5. 💡 정수 삼각형에서 이어지는 학습 포인트

| 배운 것 | 등굣길에서 적용 |
|---------|----------------|
| 2D 상태 정의 | `dp[i][j]` = (i,j)까지 경로 수 |
| 점화식 사고 | 왼쪽 + 위쪽 |
| Bottom-Up 순회 | 행 우선으로 채우기 |
| **새로운 요소** | **장애물 처리 (0으로 설정)** |
| **새로운 요소** | **mod 연산** |

---

## 6. 📐 수학 시간 격자 경로 세기와 동일!

> **"이거 옛날 수학 시간에 풀었던 거잖아?"**

맞습니다! 고등학교 확률과 통계에서 배운 **격자 경로 세기**와 완전히 동일한 방법입니다.

### 수학 시간 풀이법

```
    1 → 1 → 1 → 1
    ↓   ↓   ↓   ↓
    1 → 2 → 3 → 4
    ↓   ↓   ↓   ↓
    1 → 3 → 6 → 10
```

각 칸에 **"여기까지 오는 경로 수"**를 적고, 위+왼쪽을 더하는 방식!

### 코드로 옮긴 것

```python
# 수학 시간에 손으로 한 것
for i in range(1, n+1):
    for j in range(1, m+1):
        dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

**이게 바로 Bottom-Up DP입니다!**

---

## 7. 🔄 단계별 실행 예시 (3×3 격자)

### 초기 상태 → 최종 상태

```
시작:           채우기:          최종:
    열1 열2 열3     열1 열2 열3     열1 열2 열3
행1  0   0   0  →   1   1   1  →   1   1   1
행2  0   0   0      1   2   3      1   2   3
행3  0   0   0      1   3   6      1   3  [6]
```

### 반복문 실행 순서

| 순서 | 위치 | 계산 | 결과 |
|------|------|------|------|
| 1 | (1,1) | 시작점 | 1 |
| 2 | (1,2) | 0 + 1 | 1 |
| 3 | (1,3) | 0 + 1 | 1 |
| 4 | (2,1) | 1 + 0 | 1 |
| 5 | (2,2) | 1 + 1 | **2** |
| 6 | (2,3) | 1 + 2 | 3 |
| 7 | (3,1) | 1 + 0 | 1 |
| 8 | (3,2) | 2 + 1 | 3 |
| 9 | (3,3) | 3 + 3 | **6** ← 정답 |

### 왜 이 순서가 작동하는가?

```
[이미 계산됨] [이미 계산됨] [이미 계산됨]
[이미 계산됨] [이미 계산됨] [지금 계산 중]
      ?             ?             ?
```

- 행 우선 순회 → `dp[i][j]` 계산 시 `dp[i-1][j]`(위)와 `dp[i][j-1]`(왼쪽)이 **항상 먼저 계산됨**
- 이게 바로 **Bottom-Up**의 핵심!

---

## 8. 💡 핵심 정리

| 질문 | 답변 |
|------|------|
| **수학 시간과 동일?** | ✅ 격자 경로 세기 = DP |
| **왜 위+왼쪽?** | 오른쪽/아래로만 이동 → (i,j)에 오려면 위/왼쪽에서만 가능 |
| **왜 Bottom-Up?** | 작은 문제(시작점)부터 큰 문제(목적지)로 채워나감 |
| **물웅덩이는?** | 해당 칸 = 0으로 설정 → 경로 차단 |

---

# 평가

## 개선할 점
- **변수명 일관성 개선**: `height`, `width` 대신 문제에서 주어진 `n`, `m`을 그대로 사용하거나, `rows`, `cols` 같은 더 명확한 네이밍을 사용하면 혼동을 줄일 수 있음
- **시작점 물웅덩이 예외 처리 누락**: `dp[1][1] = 1` 설정 전에 시작점이 물웅덩이인지 확인하는 로직이 없음 (문제 조건상 발생하지 않지만, 방어적 코딩 관점에서 추가 권장)
  ```python
  if (1, 1) in puddle_set:
      return 0
  dp[1][1] = 1
  ```
- **공간 최적화 미적용**: 현재 O(m × n) 공간을 사용하지만, 행 단위로 순회하므로 O(m) 1차원 배열로 최적화 가능

## 잘한 점
- **좌표 변환 정확히 처리**: `puddles`의 `(x, y)` → `(y, x)` 변환을 set comprehension으로 간결하게 처리
  ```python
  puddle_set = {(y,x) for (x,y) in puddles}
  ```
- **MOD 연산 위치 적절**: 덧셈 결과에 즉시 MOD 연산을 적용하여 오버플로우 방지
- **주석을 통한 사고 과정 기록**: 상단 주석에서 문제 분석과 점화식 유도 과정이 잘 드러남 (특히 `dp[y][x] = 오른쪽으로 오는 경우 + 위에서 오는 경우` 부분)
- **인덱스 체계 일관성**: 1-indexed 기반으로 DP 테이블을 구성하여 경계 조건 처리가 깔끔함

## 다른 응용 방안
- **로봇이 이동하는 경우의 수**: 장애물이 있는 격자에서 목적지까지 가는 경로 수
- **체스판 위 기물 이동 경로 계산**: 특정 기물(폰, 비숍 등)의 이동 제한이 있는 경우
- **게임 맵 패스파인딩**: NPC가 갈 수 있는 경로의 다양성 계산
- **확률 계산**: 각 경로가 동일한 확률일 때 특정 지점 도달 확률

## 추천 문제
- **[프로그래머스 - 정수 삼각형](https://school.programmers.co.kr/learn/courses/30/lessons/43105)**: 같은 2D DP 구조, 경로 카운팅 대신 최대 합 계산
- **[백준 11048 - 이동하기](https://www.acmicpc.net/problem/11048)**: 격자 DP + 최대값 수집
- **[백준 1010 - 다리 놓기](https://www.acmicpc.net/problem/1010)**: 조합론과 DP의 관계 이해
- **[백준 1932 - 정수 삼각형](https://www.acmicpc.net/problem/1932)**: 정수 삼각형 원본 문제
- **[프로그래머스 - 도둑질](https://school.programmers.co.kr/learn/courses/30/lessons/42897)**: 원형 DP로 난이도 상승

## 종합 평가
격자 DP의 기본 패턴을 정확하게 이해하고 구현했습니다. 특히 **좌표 혼동**이라는 이 문제의 가장 큰 함정을 인지하고, 주석으로 `m이 가로 x, n이 세로 y`를 명시한 점이 좋습니다. 단, 코드에서 `height`, `width` 변수를 도입한 부분이 오히려 혼란을 줄 수 있습니다. 문제에서 `n`, `m`으로 주어지면 그대로 사용하거나, 아예 `rows`, `cols`처럼 배열 인덱싱과 직접 연결되는 네이밍을 사용하는 것이 실수를 줄이는 방법입니다.

코드 자체는 간결하고 DP의 핵심 점화식 `dp[y][x] = dp[y-1][x] + dp[y][x-1]`을 명확히 구현했습니다. 실전 코테에서는 현재 코드로 충분하지만, 학습 목적으로 **1차원 배열 공간 최적화**를 연습해보면 좋겠습니다. 이 패턴은 knapsack DP 등에서도 자주 등장합니다.

