# 피보나치 수 2

#DP #피보나치 #선형DP #코딩테스트

---

## 0. 한 줄 핵심

> **피보나치 점화식 `F(n) = F(n-1) + F(n-2)`를 Bottom-Up 반복문으로 O(N) 시간, O(1) 공간에 계산한다.**

---

## 1. 시그널 탐지

### 키워드 → 알고리즘 매핑

| 지문 키워드/표현 | 연상되는 알고리즘/자료구조 |
|---|---|
| "피보나치 수", "F(n) = F(n-1) + F(n-2)" | 선형 점화식 → DP |
| "n번째 피보나치 수를 구하라" | 이전 두 값에만 의존 → 공간 O(1) 최적화 가능 |

### 제약 조건 역산

- n = 0 ~ 90
- 시간 제한: 1초 → 약 10^8 연산 가능
- n이 최대 90이므로 O(N)은 물론 O(N²)도 여유
- F(90) ≈ 2.88 × 10^18 → **int 범위 초과** (C/C++은 long long 필요, Python은 자동 처리)
- **허용 복잡도**: O(N) 이하 (사실 어떤 복잡도든 통과하지만, DP 연습이 목적)

---

## 2. 개념 리마인드

**핵심 개념**

피보나치 수열은 DP의 가장 기본적인 형태다.
`F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)` (n ≥ 2)
재귀로 그대로 구현하면 같은 F(k)를 반복 계산하여 O(2^N)이 되지만,
이전 결과를 저장(메모이제이션)하면 O(N)으로 줄어든다.
F(n)이 F(n-1)과 F(n-2)에만 의존하므로 배열 없이 변수 2개로 공간 O(1)에 풀 수 있다.

**스켈레톤 참조**: [`_learning/다이나믹 프로그래밍/skeleton.md`](../../_learning/다이나믹%20프로그래밍/skeleton.md) (변형 A: 1차원 DP)

---

## 3. 알고리즘 선택 논증

**선택**: Bottom-Up DP (반복문, 변수 2개로 공간 최적화)

**선택 근거**:
- 점화식이 직전 2개 값에만 의존 → 배열 불필요, 변수 2개로 충분
- n ≤ 90이므로 반복문 90회면 끝 — 가장 단순하고 빠른 방법
- DP 입문 문제로서 "점화식 → 반복문" 변환의 기본을 익히기에 적합

### 기각된 대안

| 대안 알고리즘 | 기각 이유 |
|---|---|
| 순수 재귀 (메모이제이션 없음) | O(2^N) — n=90이면 2^90 ≈ 10^27으로 시간 초과 |
| Top-Down (메모이제이션) | 정답은 나오지만, 이 문제에선 Bottom-Up이 더 간결하고 스택 오버헤드 없음 |
| 행렬 거듭제곱 | O(log N)으로 빠르지만, n ≤ 90에서 과도한 구현 — 학습 목적에도 맞지 않음 |

---

## 4. 단계별 풀이

### 알고리즘 흐름

1. **입력 받기** — 정수 n을 읽는다 `[Code: L05]`
2. **기저 조건 처리** — n이 0이면 0, 1이면 1을 바로 반환한다. 점화식이 n ≥ 2부터 정의되므로 `[Code: L08-L09]`
3. **변수 초기화** — `prev2 = 0` (F(0)), `prev1 = 1` (F(1))로 설정한다. 직전 두 값만 기억하면 되므로 `[Code: L12-L13]`
4. **반복문으로 F(2)부터 F(n)까지 계산** — `curr = prev2 + prev1` 후 변수를 한 칸씩 시프트한다. 각 단계에서 이전 두 값의 합이 현재 값이므로 `[Code: L16-L18]`
5. **결과 출력** — 마지막으로 계산된 값이 F(n)이므로 `[Code: L20]`

### 예제 손추적

**입력**: `n = 10`

| i | prev2 (F(i-2)) | prev1 (F(i-1)) | curr (F(i)) |
|---|---|---|---|
| 초기 | 0 | 1 | - |
| 2 | 0 | 1 | **1** |
| 3 | 1 | 1 | **2** |
| 4 | 1 | 2 | **3** |
| 5 | 2 | 3 | **5** |
| 6 | 3 | 5 | **8** |
| 7 | 5 | 8 | **13** |
| 8 | 8 | 13 | **21** |
| 9 | 13 | 21 | **34** |
| 10 | 21 | 34 | **55** |

**출력**: `55`

---

## 5. 코드 구현

```python
import sys
input = sys.stdin.readline

def solve():
    # [Step 1] 입력 받기
    n = int(input())

    # [Step 2] 기저 조건 처리
    if n <= 1:
        print(n)
        return

    # [Step 3] 변수 초기화 — F(0), F(1)
    prev2 = 0  # F(0)
    prev1 = 1  # F(1)

    # [Step 4] F(2)부터 F(n)까지 반복 계산
    for i in range(2, n + 1):
        curr = prev2 + prev1
        prev2, prev1 = prev1, curr

    # [Step 5] 결과 출력
    print(prev1)

solve()
```

**복잡도**
- 시간: O(N) — 반복문 n-1회 (n ≤ 90이므로 최대 89회)
- 공간: O(1) — 변수 2개만 사용 (배열 없음)

---

## 6. 함정과 오답 분석

### 함정 테이블

| 함정 | 증상 | 해결 |
|---|---|---|
| 순수 재귀로 구현 | n=45 이상에서 시간 초과 (O(2^N)) | 반복문 또는 메모이제이션 사용 |
| F(0) = 1로 초기화 | 모든 값이 1씩 커짐 (피보나치 정의 오류) | F(0) = **0**, F(1) = 1 |
| n=0 처리 누락 | n=0 입력 시 반복문이 실행되지 않아 잘못된 값 출력 | 기저 조건에서 n ≤ 1을 별도 처리 |
| 정수 오버플로우 (C/C++) | F(90) ≈ 2.88 × 10^18 → int 범위 초과로 음수 출력 | long long 사용 (Python은 해당 없음) |

### 반례 시나리오

- **입력**: `0`
- **기대 출력**: `0`
- **오답 출력**: `1` — F(0)을 1로 잘못 초기화하거나, 기저 조건 처리 누락

- **입력**: `90`
- **기대 출력**: `2880067194370816120`
- **오답 출력 (C/C++ int)**: 음수 또는 쓰레기 값 — 정수 오버플로우

---

## 7. 다른 풀이

### 대안 풀이 A: Top-Down (메모이제이션)

재귀 함수에 딕셔너리 캐싱을 붙여 중복 계산을 제거한다. DP의 본질(재귀 + 캐싱)을 직관적으로 이해하기 좋다.

```python
import sys
sys.setrecursionlimit(200)
memo = {0: 0, 1: 1}

def fib(n):
    if n in memo:
        return memo[n]
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

### 대안 풀이 B: 배열 DP

dp 배열을 만들어 F(0)부터 F(n)까지 채운다. 모든 값을 저장하므로 중간 값을 확인하기 쉬워 디버깅에 유리하다.

```python
dp = [0] * (n + 1)
dp[1] = 1
for i in range(2, n + 1):
    dp[i] = dp[i-1] + dp[i-2]
print(dp[n])
```

**트레이드오프**:

| 비교 항목 | 현재 풀이 (변수 2개) | Top-Down | 배열 DP |
|---|---|---|---|
| 시간 복잡도 | O(N) | O(N) | O(N) |
| 공간 복잡도 | **O(1)** | O(N) | O(N) |
| 구현 난이도 | 하 | 중 | 하 |
| 디버깅 용이성 | 중 (중간값 확인 어려움) | 상 | 상 (배열 전체 출력 가능) |

**선호 시점**:
- **변수 2개**: 공간 절약이 필요하거나, 최종 값만 필요할 때 (이 문제)
- **Top-Down**: DP 개념을 처음 배울 때 "재귀 → 메모이제이션"의 변환을 체감하기 위해
- **배열 DP**: 중간 값을 확인하며 디버깅하고 싶을 때, 또는 여러 F(k) 값을 동시에 필요로 할 때

---

## 8. 패턴 카드 & 유사 문제

### 패턴 카드

```
📌 패턴명: 선형 점화식 (직전 k개 의존)
🎯 트리거: "F(n) = F(n-1) + F(n-2)" 같은 고정 개수 이전 값에 의존하는 점화식
🧩 핵심:   변수 k개로 공간 O(1) 최적화, 반복문으로 순차 계산
⚠️ 주의:   기저 조건(F(0), F(1)) 정확히 정의, 오버플로우 확인 (C/C++)
🔗 스켈레톤: _learning/다이나믹 프로그래밍/skeleton.md (변형 A)
```

### 유사 문제

| 난이도 | 문제 | 포인트 |
|---|---|---|
| ⭐ 입문 | 백준 11726 2×n 타일링 | 같은 점화식이지만 "경우의 수" + 나머지 연산 추가 |
| ⭐ 입문 | 백준 9095 1, 2, 3 더하기 | 직전 3개에 의존하는 점화식으로 확장 |
| ⭐⭐ 연습 | 백준 1463 1로 만들기 | 선택지가 3개인 min DP — 피보나치에서 한 단계 발전 |
| ⭐⭐ 연습 | 백준 2579 계단 오르기 | 조건부 점화식 — "연속 3칸 불가" 제약 추가 |
| ⭐⭐⭐ 실전 | 백준 11444 피보나치 수 6 | 행렬 거듭제곱으로 O(log N) — N이 10^18일 때 |
