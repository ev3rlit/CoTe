# 평범한 배낭

#DP #배낭문제 #Knapsack #0/1배낭 #코딩테스트

---

## 0. 한 줄 핵심

> **각 물건을 "넣는다/안 넣는다"로 분기하는 0/1 Knapsack DP를, 1D 역순 순회로 O(NK) 시간 · O(K) 공간에 푼다.**

---

## 1. 시그널 탐지

### 키워드 → 알고리즘 매핑

| 지문 키워드/표현 | 연상되는 알고리즘/자료구조 |
|---|---|
| "배낭에 넣을 수 있는 물건", "무게 제한" | 배낭 문제 (Knapsack DP) |
| "가치의 최댓값", "최대한 즐거운" | 최적화 문제 → DP |
| "하나만 넣을 수 있다" (물건을 쪼갤 수 없음) | 0/1 Knapsack (Fractional이 아님) |
| "물품의 수 N", "버틸 수 있는 무게 K" | 2차원 상태 공간 (물건 × 무게) |

### 제약 조건 역산

- N = 1 ~ 100 (물품 수)
- K = 1 ~ 100,000 (배낭 무게 한도)
- W (각 물건 무게) = 1 ~ 100,000
- V (각 물건 가치) = 0 ~ 1,000
- 시간 제한: 2초 → 약 2 × 10^8 연산 가능
- N × K = 100 × 100,000 = **10^7** → 충분히 여유
- **허용 복잡도**: O(NK) 이하

---

## 2. 개념 리마인드

**핵심 개념**

0/1 Knapsack은 각 물건을 "넣는다 / 안 넣는다" 두 가지 선택지만 있는 최적화 문제다.
상태를 `dp[i][w] = i번째 물건까지 고려했을 때, 무게 한도 w에서의 최대 가치`로 정의하면,
점화식은 `dp[i][w] = max(dp[i-1][w], dp[i-1][w-w_i] + v_i)` (단, w >= w_i일 때)가 된다.
dp[i]가 dp[i-1]에만 의존하므로 1D 배열로 공간 압축이 가능하며,
이때 **역순 순회**가 핵심이다 — 같은 물건을 중복 사용하지 않기 위함이다.

**스켈레톤 참조**: [`_learning/다이나믹 프로그래밍/skeleton.md`](../../_learning/다이나믹%20프로그래밍/skeleton.md) (변형 C: Knapsack 섹션)

---

## 3. 알고리즘 선택 논증

**선택**: 0/1 Knapsack DP (Bottom-Up, 1D 공간 최적화)

**선택 근거**:
- 각 물건마다 "넣는다/안 넣는다" 두 선택지가 있고, 부분 문제가 겹침 → **최적 부분 구조 + 중복 부분 문제** = DP 적합
- N × K = 10^7로 2초 제한 내 충분
- dp[i]가 dp[i-1]에만 의존하므로 1D 압축으로 메모리 절약 가능

### 기각된 대안

| 대안 알고리즘 | 기각 이유 |
|---|---|
| 완전탐색 (브루트포스) | O(2^N) = 2^100 ≈ 10^30 → 시간 초과 불가피 |
| 그리디 (가치/무게 비율 정렬) | 물건을 쪼갤 수 없는 0/1 문제에서 최적해를 보장하지 못함 (반례 존재) |
| Top-Down DP (메모이제이션) | 정답은 나오지만, N이 작아 재귀 오버헤드가 불필요하고 공간 최적화가 어려움 |

---

## 4. 단계별 풀이

### 알고리즘 흐름

1. **입력 받기** — N개 물건의 (무게, 가치) 쌍과 배낭 한도 K를 읽는다 `[Code: L05-L09]`
2. **DP 배열 초기화** — 크기 K+1의 1D 배열을 0으로 초기화한다. `dp[w] = 무게 한도 w일 때 최대 가치`이므로 아무 물건도 안 넣은 상태는 0이다 `[Code: L11]`
3. **물건별 순회** — 각 물건(w_i, v_i)에 대해 DP 배열을 갱신한다 `[Code: L13]`
4. **역순 무게 순회** — w를 K부터 w_i까지 **역순으로** 순회한다. 역순이므로 `dp[w - w_i]`는 아직 현재 물건을 포함하지 않은 값이다 (0/1 보장) `[Code: L15]`
5. **점화식 적용** — `dp[w] = max(dp[w], dp[w - w_i] + v_i)`. 안 넣는 경우(dp[w] 유지)와 넣는 경우(dp[w-w_i]+v_i) 중 큰 값을 취한다 `[Code: L16]`
6. **답 출력** — `dp[K]`가 최종 답이다 `[Code: L18]`

### 예제 손추적

**입력**: `N=4, K=7`

| 물건 | 무게(W) | 가치(V) |
|------|---------|---------|
| 1    | 6       | 13      |
| 2    | 4       | 8       |
| 3    | 3       | 6       |
| 4    | 5       | 12      |

**dp 배열 변화** (역순 순회 후 각 물건 처리 완료 시점):

| 단계 | dp[0] | dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | 설명 |
|---|---|---|---|---|---|---|---|---|---|
| 초기 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 아무 물건도 안 넣음 |
| 물건1 (W=6,V=13) | 0 | 0 | 0 | 0 | 0 | 0 | 13 | 13 | w=7: max(0, dp[1]+13)=13, w=6: max(0, dp[0]+13)=13 |
| 물건2 (W=4,V=8) | 0 | 0 | 0 | 0 | 8 | 8 | 13 | 13 | w=7: max(13, dp[3]+8)=13, w=4: max(0, dp[0]+8)=8 |
| 물건3 (W=3,V=6) | 0 | 0 | 0 | 6 | 8 | 8 | 13 | **14** | w=7: max(13, dp[4]+6)=**14**, w=3: max(0, dp[0]+6)=6 |
| 물건4 (W=5,V=12) | 0 | 0 | 0 | 6 | 8 | 12 | 13 | **14** | w=7: max(14, dp[2]+12)=14, w=5: max(8, dp[0]+12)=12 |

**출력**: `14` (물건2 + 물건3 = 무게 7, 가치 14)

---

## 5. 코드 구현

```python
import sys
input = sys.stdin.readline

def solve():
    # [Step 1] 입력 받기
    N, K = map(int, input().split())
    items = []
    for _ in range(N):
        w, v = map(int, input().split())
        items.append((w, v))

    # [Step 2] DP 배열 초기화 — dp[w] = 무게 한도 w일 때 최대 가치
    dp = [0] * (K + 1)

    # [Step 3] 각 물건에 대해 DP 갱신
    for w_i, v_i in items:
        # [Step 4] 역순 순회 — 같은 물건을 중복 사용하지 않기 위해
        for w in range(K, w_i - 1, -1):
            # [Step 5] 점화식 — 넣는 경우 vs 안 넣는 경우 중 큰 값
            dp[w] = max(dp[w], dp[w - w_i] + v_i)

    # [Step 6] 답 출력
    print(dp[K])

solve()
```

**복잡도**
- 시간: O(NK) = O(100 × 100,000) = O(10^7) — 각 물건에 대해 무게 0~K를 한 번씩 순회
- 공간: O(K) = O(100,000) — 1D 배열만 사용

---

## 6. 함정과 오답 분석

### 왜 역순 순회인가? — 0/1 보장의 원리

1D DP에서 점화식 `dp[w] = max(dp[w], dp[w-w_i] + v_i)`를 적용할 때, `dp[w-w_i]`는 **현재 물건이 아직 반영되지 않은 값**이어야 한다. 그래야 "이 물건을 넣을까 말까"를 판단하는 것이지, 이미 넣은 물건을 또 넣는 게 아니다.

**정순 순회 (w_i → K) — 문제 발생**

물건A (무게=3, 가치=5)를 처리한다고 가정하자.

```
w=3: dp[3] = max(dp[3], dp[0] + 5) = 5   ← 물건A 1개 반영 ✓
w=6: dp[6] = max(dp[6], dp[3] + 5) = 10  ← dp[3]에 이미 물건A가 들어있다!
```

`dp[3]`이 이미 물건A를 포함한 값(5)이므로, `dp[6]`에서 물건A를 **또 한 번** 사용하게 된다. 결과적으로 물건A가 2번 들어간 셈이다. 이렇게 정순 순회는 **Unbounded Knapsack** (물건 무한 사용 가능)이 되어버린다.

**역순 순회 (K → w_i) — 0/1 보장**

같은 물건A를 역순으로 처리하면:

```
w=6: dp[6] = max(dp[6], dp[3] + 5) = 5   ← dp[3]은 아직 0 (물건A 미반영) ✓
w=3: dp[3] = max(dp[3], dp[0] + 5) = 5   ← dp[0]도 이전 라운드 값 ✓
```

큰 무게부터 갱신하므로, 참조하는 `dp[w-w_i]`는 **아직 이번 라운드에서 건드리지 않은 값** = 이전 라운드 값(물건A 미반영)이다. 따라서 물건A는 정확히 1번만 반영된다.

**핵심 한 줄**: 역순 순회는 "아직 갱신하지 않은 칸"을 참조하게 만들어, 같은 물건의 중복 사용을 원천 차단한다.

---

### 함정 테이블

| 함정 | 증상 | 해결 |
|---|---|---|
| 정순 순회 사용 | 같은 물건이 여러 번 포함되어 답이 과대 (Unbounded Knapsack이 됨) | **역순 순회** — `range(K, w_i - 1, -1)` |
| 2D DP에서 인덱스 오프셋 | items[i-1]로 접근해야 하는데 items[i]로 접근 → IndexError | 1D 최적화를 사용하면 이 실수를 원천 차단 |
| dp 초기값 실수 | 최솟값 문제처럼 float('inf')로 초기화하면 오답 | 최대 가치 문제이므로 **0으로 초기화** |
| 무게가 K를 초과하는 물건 무시 안 함 | w_i > K인 물건에 대해 역순 순회 시 range가 비어서 문제없지만, 명시적 처리 없으면 혼란 | `range(K, w_i - 1, -1)`이 자동으로 빈 범위 생성하여 안전 |

### 반례 시나리오

- **입력**: `N=1, K=5`, 물건: `(6, 13)`
- **기대 출력**: `0` (무게 6인 물건을 용량 5에 넣을 수 없음)
- **오답 출력**: `13` — 무게 조건 검사(`w >= w_i`) 누락 시 발생

- **입력**: `N=3, K=4`, 물건: `(2, 3), (2, 3), (2, 3)`
- **기대 출력**: `6` (물건 2개만 넣을 수 있음)
- **오답 출력**: `9` — 정순 순회 시 같은 물건을 중복 사용하여 3개 모두 넣은 것으로 계산

---

## 7. 다른 풀이

### 대안 풀이 A: 2D DP 테이블 (기본형)

dp[i][w]를 (N+1) × (K+1) 2차원 배열로 명시적으로 관리한다.
직관적이고 디버깅이 쉽지만 메모리 사용이 크다.

```python
dp = [[0] * (K + 1) for _ in range(N + 1)]
for i in range(1, N + 1):
    w_i, v_i = items[i - 1]
    for w in range(K + 1):
        if w >= w_i:
            dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - w_i] + v_i)
        else:
            dp[i][w] = dp[i - 1][w]
print(dp[N][K])
```

### 대안 풀이 B: Top-Down (메모이제이션)

재귀로 필요한 상태만 계산한다. 상태 공간이 희소할 때 유리하지만, 이 문제에서는 대부분의 상태를 방문하므로 이점이 적다.

**트레이드오프**:

| 비교 항목 | 현재 풀이 (1D Bottom-Up) | 2D Bottom-Up | Top-Down |
|---|---|---|---|
| 시간 복잡도 | O(NK) | O(NK) | O(NK) |
| 공간 복잡도 | O(K) | O(NK) | O(NK) + 재귀 스택 |
| 구현 난이도 | 중 (역순 이해 필요) | 하 (직관적) | 중 (재귀 설계) |
| 디버깅 용이성 | 중 | 상 (테이블 전체 출력 가능) | 하 |

**선호 시점**:
- **2D Bottom-Up**: DP를 처음 배울 때, 또는 디버깅이 필요할 때
- **Top-Down**: 상태 공간이 희소하거나 가지치기가 효과적인 변형 문제에서
- **1D Bottom-Up**: 공간 최적화가 필요하거나 본 문제처럼 메모리 제한이 빠듯할 때

---

## 8. 패턴 카드 & 유사 문제

### 패턴 카드

```
📌 패턴명: 0/1 Knapsack (1D 공간 최적화)
🎯 트리거: "N개 물건, 용량 제한, 최대 가치" + 물건을 쪼갤 수 없음
🧩 핵심:   dp[w] = max(dp[w], dp[w-w_i] + v_i), 역순 순회로 0/1 보장
⚠️ 주의:   정순 순회하면 Unbounded Knapsack이 됨 (같은 물건 중복 사용)
🔗 스켈레톤: _learning/다이나믹 프로그래밍/skeleton.md (변형 C)
```

### 유사 문제

| 난이도 | 문제 | 포인트 |
|---|---|---|
| ⭐ 입문 | 백준 2293 동전 1 | Unbounded Knapsack — 정순 순회와 비교하며 차이점 체감 |
| ⭐ 입문 | 프로그래머스 거스름돈 | 경우의 수를 세는 배낭 변형 (합 대신 카운팅) |
| ⭐⭐ 연습 | 백준 7579 앱 | 배낭의 "용량"을 비용으로, "가치"를 메모리로 치환한 변형 |
| ⭐⭐ 연습 | 백준 1450 냅색문제 | Meet in the Middle + 이분탐색 (N이 커서 일반 DP 불가) |
| ⭐⭐⭐ 실전 | 백준 2629 양팔저울 | 가능/불가능 판단형 배낭 — dp를 bool 배열로 관리 |
