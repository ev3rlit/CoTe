# 1로 만들기

#DP #선형DP #최솟값 #코딩테스트

---

## 0. 한 줄 핵심

> **3으로 나누기, 2로 나누기, 1 빼기 — 세 가지 연산 중 최소 횟수를 dp[i] = min(dp[i/3], dp[i/2], dp[i-1]) + 1로 구한다.**

---

## 1. 시그널 탐지

### 키워드 → 알고리즘 매핑

| 지문 키워드/표현 | 연상되는 알고리즘/자료구조 |
|---|---|
| "1로 만들기 위해 사용하는 연산의 횟수의 최솟값" | 최솟값 → DP 또는 BFS |
| "3가지 연산", "3으로 나누기 / 2로 나누기 / 1 빼기" | 유한한 선택지에서 최적 선택 → DP |
| "정수 N이 주어졌을 때" | 상태: 현재 숫자 → dp[i] 정의 가능 |

### 제약 조건 역산

- N = 1 ~ 10^6
- 시간 제한: 0.15초 (Python 추가 시간 적용 시 약 2초)
- O(N) = 10^6 → 충분
- O(N log N) 이상은 불필요 (N이 충분히 작음)
- **허용 복잡도**: O(N) 이하

---

## 2. 개념 리마인드

**핵심 개념**

이 문제는 "현재 상태에서 가능한 선택지 중 최소 비용을 고르는" 전형적인 1D DP다.
`dp[i] = 정수 i를 1로 만드는 최소 연산 횟수`로 정의하면,
i에서 갈 수 있는 곳은 `i-1`, `i/2` (2의 배수일 때), `i/3` (3의 배수일 때)이다.
점화식: `dp[i] = min(갈 수 있는 곳의 dp값) + 1`
피보나치가 "이전 값을 더하는" DP였다면, 이 문제는 "여러 선택지 중 min을 고르는" DP다.

**스켈레톤 참조**: [`_learning/다이나믹 프로그래밍/skeleton.md`](../../_learning/다이나믹%20프로그래밍/skeleton.md) (변형 A: 1차원 DP)

---

## 3. 알고리즘 선택 논증

**선택**: Bottom-Up DP (1D 배열)

**선택 근거**:
- 상태가 정수 i 하나로 정의되고, 작은 i부터 큰 i까지 순차 계산 가능
- O(N) 시간, O(N) 공간으로 충분
- 구현이 단순하고 직관적

### 기각된 대안

| 대안 알고리즘 | 기각 이유 |
|---|---|
| BFS (1을 시작점으로) | 정답은 나오지만, 큐 오버헤드가 있고 DP가 더 자연스럽고 간결 |
| 그리디 (항상 큰 수로 나누기) | **오답** — 10 → 5 → 4 → 2 → 1 (4회)보다 10 → 9 → 3 → 1 (3회)가 최적 |
| Top-Down (메모이제이션) | 가능하지만 N=10^6에서 재귀 깊이 초과 위험 (sys.setrecursionlimit 필요) |

---

## 4. 단계별 풀이

### 알고리즘 흐름

1. **DP 배열 초기화** — 크기 N+1의 배열을 생성한다. `dp[1] = 0`으로 설정한다. 1은 이미 1이므로 연산 0회이므로 `[Code: L07-L08]`
2. **i=2부터 N까지 순회** — 각 i에 대해 가능한 세 가지 연산의 역방향을 고려한다 `[Code: L11]`
3. **1 빼기 연산** — `dp[i] = dp[i-1] + 1`로 시작한다. 항상 가능한 연산이므로 기본값으로 설정 `[Code: L13]`
4. **2로 나누기 연산** — i가 2의 배수이면 `dp[i] = min(dp[i], dp[i//2] + 1)`로 갱신한다. 더 적은 횟수가 있을 수 있으므로 `[Code: L15-L16]`
5. **3으로 나누기 연산** — i가 3의 배수이면 `dp[i] = min(dp[i], dp[i//3] + 1)`로 갱신한다. 마찬가지로 더 적은 횟수가 있을 수 있으므로 `[Code: L18-L19]`
6. **답 출력** — `dp[N]`이 최종 답이므로 `[Code: L21]`

### 예제 손추적

**입력**: `N = 10`

| i | dp[i-1]+1 | dp[i//2]+1 | dp[i//3]+1 | dp[i] | 최적 경로 |
|---|---|---|---|---|---|
| 1 | - | - | - | **0** | (기저) |
| 2 | dp[1]+1=1 | dp[1]+1=1 | - | **1** | 2→1 |
| 3 | dp[2]+1=2 | - | dp[1]+1=1 | **1** | 3→1 |
| 4 | dp[3]+1=2 | dp[2]+1=2 | - | **2** | 4→2→1 |
| 5 | dp[4]+1=3 | - | - | **3** | 5→4→2→1 |
| 6 | dp[5]+1=4 | dp[3]+1=2 | dp[2]+1=2 | **2** | 6→3→1 |
| 7 | dp[6]+1=3 | - | - | **3** | 7→6→3→1 |
| 8 | dp[7]+1=4 | dp[4]+1=3 | - | **3** | 8→4→2→1 |
| 9 | dp[8]+1=4 | - | dp[3]+1=2 | **2** | 9→3→1 |
| 10 | dp[9]+1=3 | dp[5]+1=4 | - | **3** | 10→9→3→1 |

**출력**: `3`

핵심 관찰: 10에서 그리디로 2로 나누면 10→5→4→2→1 (4회)이지만, DP는 10→9→3→1 (3회)을 찾아낸다.

---

## 5. 코드 구현

```python
import sys
input = sys.stdin.readline

def solve():
    # [Step 1] 입력 및 DP 초기화
    n = int(input())

    dp = [0] * (n + 1)
    # dp[1] = 0 (이미 0으로 초기화됨)

    # [Step 2] i=2부터 순회
    for i in range(2, n + 1):
        # [Step 3] 1 빼기 — 항상 가능, 기본값
        dp[i] = dp[i - 1] + 1

        # [Step 4] 2로 나누기 — 2의 배수일 때만
        if i % 2 == 0:
            dp[i] = min(dp[i], dp[i // 2] + 1)

        # [Step 5] 3으로 나누기 — 3의 배수일 때만
        if i % 3 == 0:
            dp[i] = min(dp[i], dp[i // 3] + 1)

    # [Step 6] 답 출력
    print(dp[n])

solve()
```

**복잡도**
- 시간: O(N) — 2부터 N까지 한 번 순회, 각 i에서 상수 시간 연산
- 공간: O(N) — dp 배열 크기 N+1

---

## 6. 함정과 오답 분석

### 그리디가 왜 틀리는가?

"가능한 한 큰 수로 나누는 것이 항상 최적"이라고 생각하기 쉽지만, 반례가 존재한다.

**그리디 전략**: 3으로 나눌 수 있으면 나누고, 아니면 2로, 아니면 1 빼기

- N=10: 3의 배수 아님 → 2로 나누기 → 5 → 1 빼기 → 4 → 2 → 1 = **4회** (오답)
- N=10 최적: 10 → 9(-1) → 3(÷3) → 1(÷3) = **3회**

1을 빼서 3의 배수로 만든 뒤 나누는 것이 더 빠를 수 있기 때문에, 모든 선택지를 비교하는 DP가 필요하다.

### 함정 테이블

| 함정 | 증상 | 해결 |
|---|---|---|
| 그리디 접근 | 일부 입력에서 최적이 아닌 답 출력 | DP로 모든 선택지의 min을 비교 |
| dp[1] 초기화 누락 | dp[2], dp[3] 계산 시 잘못된 기본값 참조 | dp[1] = 0 명시 (또는 0으로 초기화된 배열 사용) |
| 나누기 조건 검사 누락 | i%2 != 0인데 i//2를 참조 → 잘못된 상태 참조 | `if i % 2 == 0`, `if i % 3 == 0` 조건 필수 |
| N=1 예외 처리 | N=1이면 반복문 실행 안 됨 → dp[1]=0 출력 필요 | dp[1]=0 초기화로 자동 처리 |

### 반례 시나리오

- **입력**: `10`
- **기대 출력**: `3` (10→9→3→1)
- **오답 출력 (그리디)**: `4` (10→5→4→2→1) — 항상 큰 수로 나누려다 최적해를 놓침

- **입력**: `1`
- **기대 출력**: `0`
- **오답 출력 (초기화 실수)**: `1` — dp[1]을 1로 잘못 설정

---

## 7. 다른 풀이

### 대안 풀이 A: BFS (1에서 N까지)

1을 시작점으로 두고, 각 숫자에서 ×3, ×2, +1 연산으로 N에 도달하는 최단 거리를 BFS로 구한다. "최소 횟수" = "최단 거리"이므로 BFS의 레벨이 곧 답이다.

### 대안 풀이 B: Top-Down (메모이제이션)

```python
from functools import lru_cache
import sys
sys.setrecursionlimit(10**6 + 10)

@lru_cache(maxsize=None)
def dp(n):
    if n == 1: return 0
    result = dp(n - 1) + 1
    if n % 2 == 0: result = min(result, dp(n // 2) + 1)
    if n % 3 == 0: result = min(result, dp(n // 3) + 1)
    return result
```

**트레이드오프**:

| 비교 항목 | 현재 풀이 (Bottom-Up) | BFS | Top-Down |
|---|---|---|---|
| 시간 복잡도 | O(N) | O(N) | O(N) |
| 공간 복잡도 | O(N) | O(N) (큐 + visited) | O(N) + 재귀 스택 |
| 구현 난이도 | 하 | 중 | 하 |
| 스택 오버플로우 | 없음 | 없음 | 위험 (N=10^6) |

**선호 시점**:
- **Bottom-Up**: 이 문제의 정석. 간결하고 안전
- **BFS**: "최단 거리" 관점으로 문제를 이해하고 싶을 때 (DP와 BFS의 관계 체감)
- **Top-Down**: N이 작은 변형에서 빠르게 구현할 때 (재귀 깊이 주의)

---

## 8. 패턴 카드 & 유사 문제

### 패턴 카드

```
📌 패턴명: 다중 선택지 min DP
🎯 트리거: "N을 1로 만드는 최소 연산 횟수" — 유한한 연산 중 최적 선택
🧩 핵심:   dp[i] = min(가능한 이전 상태들의 dp값) + 1
⚠️ 주의:   그리디 ≠ 최적 — 반드시 모든 선택지를 비교해야 함
🔗 스켈레톤: _learning/다이나믹 프로그래밍/skeleton.md (변형 A)
```

### 유사 문제

| 난이도 | 문제 | 포인트 |
|---|---|---|
| ⭐ 입문 | 백준 2748 피보나치 수 2 | 선택지 없이 이전 값을 더하는 가장 기본적인 DP |
| ⭐ 입문 | 백준 11726 2×n 타일링 | 선택지 2개(1칸/2칸)의 경우의 수 DP |
| ⭐⭐ 연습 | 백준 2579 계단 오르기 | 선택지에 "연속 3칸 불가" 제약이 추가된 DP |
| ⭐⭐ 연습 | 백준 9095 1, 2, 3 더하기 | 선택지 3개의 경우의 수 카운팅 (min이 아닌 합) |
| ⭐⭐⭐ 실전 | 백준 12852 1로 만들기 2 | 같은 문제 + 경로 역추적 — dp값뿐 아니라 어떤 선택을 했는지 기록 |
