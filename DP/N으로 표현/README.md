# N으로 표현

#DP #동적계획법 #집합DP #코딩테스트 #프로그래머스

## 문제 난이도: 중상 (Lv.3)

> **문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/42895

---

## 문제 요약

숫자 N과 사칙연산(+, -, *, /)만 사용해서 number를 표현할 때, N 사용 횟수의 **최솟값**을 구하라.

**예시**: N=5, number=12
- `5 + 5 + (5 / 5) + (5 / 5)` → 5를 6번 사용
- `55 / 5 + 5 / 5` → 5를 5번 사용  
- `(55 + 5) / 5` → 5를 4번 사용 ✅ 최소

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| N (사용할 숫자) | 1~9 | 한 자리 숫자만 사용 |
| number (목표 숫자) | 1~32,000 | 목표 범위가 넓지 않음 |
| 최대 사용 횟수 | 8 | 8보다 크면 -1 반환 → **탐색 범위 제한** |
| 나눗셈 | 정수 나눗셈 | 나머지 무시 |

### 1.2 시간 복잡도 역산

**핵심 관찰**: N을 최대 8번만 사용하므로 **상태 공간이 매우 제한적**

- N을 k번 사용해서 만들 수 있는 수의 집합 크기는?
  - k=1: 1개 (N 자체)
  - k=2: 최대 수십 개 (N, NN, N+N, N-N, N*N, N/N)
  - k=8: 최대 수만 개 (여전히 관리 가능)

**결론**: 전체 상태 수가 10^5 이하 → **완전탐색 + 메모이제이션 가능**

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **최솟값** (최소 사용 횟수) | DP 또는 BFS |
| 순서가 중요한가 | 연산 순서 중요 (괄호 고려) | 분할 정복적 접근 |
| 부분 문제로 나눌 수 있는가 | **YES!** - "k번 사용한 수" = "i번 사용한 수" ⊕ "k-i번 사용한 수" | **집합 DP** |
| 탐욕적 선택이 최적인가 | NO - 어떤 연산이 최적인지 미리 알 수 없음 | 전체 탐색 필요 |

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: 집합 DP (Set-based DP)

**핵심 아이디어**:
```
dp[k] = "N을 정확히 k번 사용해서 만들 수 있는 모든 수의 집합"
```

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - N을 k번 사용한 수 = (i번 사용한 수) ⊕ (k-i번 사용한 수)
   - 예: `dp[4]`에는 `dp[1] ⊕ dp[3]`, `dp[2] ⊕ dp[2]`, `dp[3] ⊕ dp[1]`의 모든 조합 포함
   - 이 **분할 구조**가 DP의 핵심

2. **제약 조건 충족**
   - k는 최대 8 → 8개의 집합만 관리
   - 각 집합 크기는 실험적으로 수만 개 이하 → **충분히 빠름**

3. **핵심 인사이트**
   - **N을 이어 붙인 수**도 고려해야 함: `5, 55, 555, 5555, ...`
   - `dp[k]`에 `NNN...N` (N이 k개)를 먼저 추가

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| BFS | O(상태수 × 연산수) | 가능하지만 상태 정의가 복잡 (숫자 + 사용횟수) |
| 완전탐색 (재귀) | 지수적 | 중복 계산 많음, 메모이제이션 필요 → 결국 DP |
| 수학적 접근 | - | 사칙연산 조합이 불규칙해서 패턴 없음 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "최소 사용 횟수", "N번 이하로 만들기", "조합으로 목표 도달"
- **문제 유형**: 제한된 자원으로 목표 달성, 최소 연산 횟수
- **주의사항**: 
  - 이어 붙인 수(`55`, `555`)를 빠뜨리기 쉬움
  - 나눗셈에서 0으로 나누는 경우 처리
  - 음수도 중간 결과로 가능 (빼기 연산)

---

## 2. 🧠 자연어 실행 흐름

1. **초기화**: `dp[1]`부터 `dp[8]`까지 빈 집합으로 시작
   
2. **기저 조건 설정**:
   - `dp[1] = {N}` (N 한 개로 만들 수 있는 수)
   - `dp[2]`에는 `NN`과 `dp[1] ⊕ dp[1]`의 결과 추가
   - ...
   - `dp[k]`에는 `NNN...N` (k자리)를 먼저 추가

3. **점화식 적용** (k = 2부터 8까지):
   - `dp[k]`에 이어 붙인 수 추가: `N * (10^k - 1) / (10 - 1)` = `NNN...N`
   - 모든 분할 (i, k-i)에 대해 (i = 1 ~ k-1):
     - `dp[i]`의 모든 수 a와 `dp[k-i]`의 모든 수 b에 대해:
       - `a + b`, `a - b`, `a * b` 를 `dp[k]`에 추가
       - `b ≠ 0`이면 `a // b`도 추가

4. **조기 종료**: 각 k에서 `number`가 `dp[k]`에 있으면 즉시 k 반환

5. **결과 반환**: k=8까지 찾지 못하면 -1 반환

---

## 3. 💻 Code Implementation

```python
def solution(N, number):
    # 예외 처리: number가 N 자체인 경우
    if N == number:
        return 1
    
    # dp[i] = N을 i번 사용해서 만들 수 있는 모든 수의 집합
    dp = [set() for _ in range(9)]  # 1~8 사용
    
    # k번 사용하는 경우를 탐색
    for k in range(1, 9):
        # 1. N을 k번 이어 붙인 수 추가 (예: 5, 55, 555, ...)
        repeated_n = int(str(N) * k)
        dp[k].add(repeated_n)
        
        # 2. 모든 분할 조합 탐색: dp[i] ⊕ dp[k-i]
        for i in range(1, k):
            for a in dp[i]:
                for b in dp[k - i]:
                    dp[k].add(a + b)      # 덧셈
                    dp[k].add(a - b)      # 뺄셈
                    dp[k].add(a * b)      # 곱셈
                    if b != 0:            # 나눗셈 (0으로 나누기 방지)
                        dp[k].add(a // b)
        
        # 3. 목표 숫자를 찾으면 즉시 반환
        if number in dp[k]:
            return k
    
    # 8번 이내에 만들 수 없으면 -1
    return -1
```

**복잡도 분석**
- **시간**: O(∑(|dp[i]| × |dp[k-i]|)) - 실험적으로 10^6 이하
- **공간**: O(∑|dp[k]|) - 각 집합의 총 크기, 수만 개 이하

---

## 4. 🔍 핵심 포인트 정리

### 왜 집합(Set)을 사용하는가?
- 같은 수가 여러 방법으로 만들어질 수 있음 → **중복 제거** 필수
- 예: `5 + 5 = 10`, `55 / 5 - 1 = 10` → 둘 다 같은 10

### 왜 k=1부터 순차적으로 탐색하는가?
- **최솟값**을 찾는 문제이므로, 작은 k부터 탐색하면 처음 발견한 k가 정답
- 조기 종료로 불필요한 계산 방지

### 이어 붙인 수를 왜 따로 처리하는가?
- `55`는 `5`와 `5`의 사칙연산으로 만들 수 없음
- 각 `dp[k]`의 초기값으로 `NNN...N` (k자리)를 명시적으로 추가

### 음수는 왜 허용하는가?
- 중간 계산에서 음수가 나올 수 있음 (예: `5 - 55 = -50`)
- 이후 연산으로 양수가 될 수 있으므로 제거하면 안 됨

---

# 평가

## 🤔 코드 주석의 의문에 대한 답변

> **"왜 a-b와 b-a는 서로 다른 결과인데 신경쓰지 않는가?"**
> **"a//b와 b//a도 결과가 다르지만 없음?"**

**훌륭한 관찰입니다!** 실제로 `a-b ≠ b-a`, `a//b ≠ b//a`인 경우가 많습니다.

**하지만 문제없습니다. 왜냐하면:**

```python
# i=1, k-i=3 일 때
for a in dp[1]:      # a = dp[1]의 원소
    for b in dp[3]:  # b = dp[3]의 원소
        dp[k].add(a - b)  # dp[1] - dp[3]

# i=3, k-i=1 일 때 (나중에 실행됨)
for a in dp[3]:      # a = dp[3]의 원소  
    for b in dp[1]:  # b = dp[1]의 원소
        dp[k].add(a - b)  # dp[3] - dp[1]  ← 순서가 바뀜!
```

**`range(1, k)`가 `i=1, 2, ..., k-1`을 모두 순회**하므로:
- `i=1, k-i=3` → `dp[1] - dp[3]` (= a-b)
- `i=3, k-i=1` → `dp[3] - dp[1]` (= b-a와 동일한 효과)

**결론**: 모든 순서 조합이 자동으로 커버됩니다! 👍

---

## 개선할 점

### 1. 마지막 줄의 문법 오류
```python
return -1
            
    .   # ← 이 점(.) 제거 필요
```

### 2. 변수명 개선 가능
```python
# 현재
repeated = int(str(N)*k)

# 개선 제안
concatenated = int(str(N) * k)  # "이어붙인 수"라는 의미가 더 명확
```

### 3. 나눗셈 대칭성 처리 누락
현재 코드는 `a // b`만 처리하고 `b // a`를 처리하지 않습니다.

**하지만!** 위에서 설명했듯이, `i`와 `k-i`가 바뀌는 순회에서 자동으로 처리됩니다.
단, **같은 크기 집합끼리의 연산** (`dp[2] ⊕ dp[2]` 등)에서는 문제가 될 수 있습니다.

```python
# i=2, k-i=2 일 때 (k=4)
for a in dp[2]:
    for b in dp[2]:
        dp[k].add(a // b)  # a=10, b=55 → 0
        # b // a 는 언제? → 다음 반복에서 a=55, b=10 으로 나옴!
```

**결론**: dp[i]와 dp[k-i]가 같은 집합일 때도, 이중 for문이 `(a,b)`와 `(b,a)` 모두 순회하므로 OK!

---

## 잘한 점

### 1. 문제 이해를 주석으로 정리
```python
# dp[k] = N를 k번 사용할때 나올 수 있는 모든 결과의 집합
# dp[k] = dp[i] 번 사용한 집합 과  dp[k-i] 번 사용한 집합
```
**핵심 아이디어를 먼저 정리한 후 코딩** - 좋은 습관입니다.

### 2. 의문점을 주석으로 남김
```python
# 왜 a-b와 b-a는 서로 다른 결과인데 신경쓰지 않는가?
```
**"왜?"라는 질문을 던지는 것**이 진짜 학습입니다. 단순히 외우지 않고 이해하려는 자세가 보입니다.

### 3. 엣지 케이스 처리
```python
if N == number:
    return 1
```
`N = number`인 경우 조기 반환 - 불필요한 연산 방지.

### 4. 0으로 나누기 방지
```python
if b != 0:
    dp[k].add(a // b)
```
런타임 에러 방지를 놓치지 않았습니다.

---

## 다른 응용 방안

이 **집합 DP** 패턴은 다음 상황에서 활용 가능:

| 상황 | 예시 |
|------|------|
| **제한된 연산으로 목표 도달** | 동전 조합, 주사위 합 |
| **최소 사용 횟수** | 최소 연산으로 목표값 만들기 |
| **가능한 모든 결과 열거** | 수식 결과 경우의 수 |
| **분할 가능한 문제** | `f(k) = f(i) ⊕ f(k-i)` 형태 |

---

## 추천 문제

| 문제 | 유형 | 난이도 |
|------|------|--------|
| 프로그래머스 - 거스름돈 | 집합 DP (동전 조합) | Lv.2 |
| 프로그래머스 - 타겟 넘버 | DFS + 완전탐색 | Lv.2 |
| 백준 1699 - 제곱수의 합 | DP (최소 개수) | Silver 2 |
| 백준 2294 - 동전 2 | DP (최소 동전 수) | Silver 1 |

---

## 종합 평가

**핵심 알고리즘(집합 DP)을 정확히 이해하고 구현했습니다.**

특히 인상적인 점은 코드에 남긴 의문입니다:
> "왜 a-b와 b-a를 따로 처리하지 않는가?"

이 질문을 던졌다는 것은 **단순히 코드를 복사한 게 아니라, 로직을 따라가며 이해하려 했다**는 증거입니다.

실제로 이 의문의 답("i와 k-i가 바뀌면서 자동으로 커버됨")을 이해하면, 비슷한 분할 DP 문제에서도 **같은 실수를 하지 않게 됩니다**.

**다음 단계 제안**:
1. `.` 문법 오류 수정
2. 테스트 케이스 몇 개 직접 손으로 추적해보기 (dp[1]→dp[2]→dp[3], N=5로)
3. 비슷한 패턴의 "거스름돈" 문제 풀어보기
