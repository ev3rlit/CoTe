# RGB거리

#DP #다이나믹프로그래밍 #알고리즘 #코딩테스트

## 문제 난이도: 하

---

## 1. 📊 객관적 분석 및 근거

### 1.1 제약 조건 파악

| 항목 | 값 | 의미 |
|------|-----|------|
| N (집의 수) | 2 ≤ N ≤ 1,000 | 최대 1,000개의 집으로 O(N²) 이하 알고리즘 사용 가능 |
| 비용 범위 | 1 ≤ cost ≤ 1,000 | 최대 총 비용 = 1,000 × 1,000 = 10^6 (int 범위 내) |
| 시간 제한 | 0.5초 | 약 5×10^7 연산 이내 |
| 메모리 제한 | 128MB | 약 3,200만 개의 int 배열 가능 |

### 1.2 시간 복잡도 역산

**기준**: 1초 ≈ 10^8 연산

| 복잡도 | N=1,000 | N=10,000 | N=100,000 | N=1,000,000 |
|--------|---------|----------|-----------|-------------|
| O(N) | 1,000 ✅ | 10,000 ✅ | 100,000 ✅ | 1,000,000 ✅ |
| O(N log N) | 10,000 ✅ | 130,000 ✅ | 1,700,000 ✅ | 20,000,000 ✅ |
| O(N²) | 1,000,000 ✅ | 100,000,000 ⚠️ | 10^10 ❌ | 10^12 ❌ |
| O(N³) | 10^9 ❌ | 10^12 ❌ | 10^15 ❌ | 10^18 ❌ |

**이 문제의 경우**:
- N = 최대 1,000 이므로
- 시간 제한이 0.5초로, 약 5×10^7 연산 이내 필요
- **결론**: O(N) ~ O(N²) 범위의 알고리즘 사용 가능

### 1.3 문제 패턴 인식

**핵심 질문**: 이 문제가 요구하는 것은 무엇인가?

| 관찰 포인트 | 이 문제에서 | 시사점 |
|-------------|-------------|--------|
| 최적해 vs 모든 경우 | **최솟값** (최적해) | 완전탐색보다 DP/그리디 고려 |
| 순서가 중요한가 | **매우 중요** (1번→N번 순서대로 결정) | 정렬 불가, 순차적 처리 필요 |
| 부분 문제로 나눌 수 있는가 | **있음** (i번째 집까지의 최소 비용) | DP 적용 가능 |
| 탐욕적 선택이 최적인가 | **아님** (현재 최소가 전체 최소 아님) | 그리디 불가 |

**그리디가 안 되는 이유**:
- 예제 3: `1 100 100` / `100 100 100` / `1 100 100`
- 그리디로 1번 집에서 빨강(1)을 선택하면, 3번 집에서 빨강(1)을 못 써서 100을 선택해야 함
- 1번 집에서 초록(100)을 선택하면, 3번 집에서 빨강(1)을 선택 가능
- 최적해는 1 + 100 + 1 = 102가 아닌 100 + 100 + 1 = 201... (아니, 1 + 100 + 1 = 102!)
- 실제로는: 빨강(1) → 파랑(100) → 빨강(1) = 102 (정답)

### 1.4 알고리즘 선택 및 논증

#### 🎯 최종 선택: Dynamic Programming (DP)

**선택 근거 (Why this algorithm?)**

1. **문제 구조와의 적합성**
   - **최적 부분 구조**: i번째 집까지 칠하는 최소 비용은, (i-1)번째 집까지의 최소 비용에서 유도 가능
   - **중복 부분 문제**: 같은 상태(i번째 집을 특정 색으로 칠할 때의 최소 비용)가 반복 계산됨

2. **상태 정의**
   - `dp[i][c]` = i번째 집을 색상 c로 칠할 때, 1~i번째 집을 칠하는 **최소 비용**
   - c ∈ {0: 빨강, 1: 초록, 2: 파랑}

3. **점화식**
   ```
   dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0]  # 빨강
   dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1]  # 초록
   dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + cost[i][2]  # 파랑
   ```

4. **제약 조건 충족**
   - 시간 복잡도: O(N × 3) = O(N) → N=1,000일 때 약 3,000회 연산 (✅ 통과)
   - 공간 복잡도: O(N × 3) = O(N) → 약 12KB 사용 (✅ 통과)
   - 공간 최적화 시: O(3) = O(1)로 줄일 수 있음

5. **핵심 인사이트**
   - **인접 제약 조건**: "인접한 집은 같은 색을 칠할 수 없다"
   - 이 조건은 현재 결정이 **바로 이전 결정에만 의존**함을 의미
   - 따라서 1차원 DP로 해결 가능 (상태 = 현재 위치 + 색상)

#### ❌ 기각된 대안들

| 대안 | 복잡도 | 기각 이유 |
|------|--------|-----------|
| 완전 탐색 (Brute Force) | O(3^N) | N=1,000일 때 3^1000은 천문학적 숫자 |
| 그리디 (Greedy) | O(N) | 국소 최적 ≠ 전역 최적 (반례 존재) |
| BFS/DFS | O(3^N) | 모든 경로 탐색 필요, 완전 탐색과 동일 |

#### 💡 비슷한 문제에서 이 패턴을 인식하는 법

- **키워드**: "최소 비용", "인접한 것은 같을 수 없다", "순서대로 선택"
- **문제 유형**: 
  - 1차원 배열에서 각 위치마다 여러 선택지가 있고, 인접 제약이 있는 경우
  - 집/타일/색칠 문제에서 자주 등장
- **주의사항**: 
  - 원형 배열이면 첫 번째와 마지막 원소도 인접 → 케이스 분리 필요 (예: 도둑질 문제)
  - 이 문제는 선형이므로 케이스 분리 불필요

---

## 2. 🧠 자연어 실행 흐름

(코드 없이 순수 한글로 작성)

1. **입력 처리**: N개 집의 RGB 비용을 2차원 배열로 저장
2. **초기화**: 첫 번째 집의 각 색상 비용으로 dp 테이블 초기화
   - `dp[0][R]` = 첫 번째 집을 빨강으로 칠하는 비용
   - `dp[0][G]` = 첫 번째 집을 초록으로 칠하는 비용
   - `dp[0][B]` = 첫 번째 집을 파랑으로 칠하는 비용
3. **점화식 적용**: 2번째 집부터 N번째 집까지 순회
   - 각 집에 대해 3가지 색상 각각에 대해:
     - 이전 집에서 **다른 두 색상의 최솟값** + 현재 색상 비용
4. **결과 도출**: N번째 집의 3가지 색상 중 최솟값 출력

---

## 3. 💻 Code Implementation

(언어: Python)

```python
import sys
input = sys.stdin.readline

def solution():
    # 입력 처리
    N = int(input())
    costs = [list(map(int, input().split())) for _ in range(N)]
    
    # DP 테이블 초기화 (공간 최적화: 이전 행만 저장)
    prev = costs[0][:]  # 첫 번째 집의 비용으로 초기화
    
    # 점화식 적용
    for i in range(1, N):
        curr = [0, 0, 0]
        curr[0] = min(prev[1], prev[2]) + costs[i][0]  # 빨강
        curr[1] = min(prev[0], prev[2]) + costs[i][1]  # 초록
        curr[2] = min(prev[0], prev[1]) + costs[i][2]  # 파랑
        prev = curr
    
    # 결과: 마지막 집의 세 색상 중 최솟값
    print(min(prev))

solution()
```

**복잡도 분석**
- 시간: O(N) - N개의 집을 한 번씩 순회하며 상수 시간 연산
- 공간: O(1) - 이전 상태만 저장 (3개의 변수)

---

## 4. 📝 회고 (추후 작성)

### 잘한 점
- (풀이 후 작성)

### 개선할 점  
- (풀이 후 작성)

### 배운 점
- (풀이 후 작성)

---

# 평가

## 개선할 점

1. **점화식 코드 반복을 루프로 일반화 가능**
   ```python
   # 현재 (명시적이지만 반복적)
   curr[0] = min(prev[1], prev[2]) + costs[i][0]
   curr[1] = min(prev[0], prev[2]) + costs[i][1]
   curr[2] = min(prev[0], prev[1]) + costs[i][2]
   
   # 일반화 버전 (확장성 있음)
   for c in range(3):
       curr[c] = min(prev[(c+1) % 3], prev[(c+2) % 3]) + costs[i][c]
   ```
   - 현재 코드가 더 직관적이고 가독성이 좋지만, 색상 수가 늘어나면 루프 버전이 유리
   - 코테에서는 **현재 방식이 더 안전** (실수 가능성 낮음)

2. **상수 정의로 매직 넘버 제거 (선택적)**
   ```python
   R, G, B = 0, 1, 2  # 인덱스에 의미 부여
   ```
   - 다만 이 정도 규모에서는 오버엔지니어링일 수 있음

3. **주석의 점화식 오류**
   - 14번 줄: `dp[i][j] = min(dp[i-1][j], dp[i-1][j-1])`은 잘못된 점화식
   - 실제 구현은 올바름: `dp[i][j] = min(dp[i-1][다른 두 색]) + costs[i][j]`
   - 사고 과정에서 수정된 것으로 보이나, 주석 정리 필요

## 잘한 점

1. **공간 최적화 적용**
   - `prev`와 `curr` 두 개의 배열만 사용하여 O(1) 공간 달성
   - 분석 문서의 "공간 최적화 시 O(3) = O(1)" 인사이트를 바로 적용

2. **분석 → 구현 흐름 학습**
   - 분석 문서의 점화식을 그대로 코드로 옮김
   - 이 과정 자체가 DP 문제 접근법을 익히는 좋은 학습 방법

3. **초기 사고 과정 기록**
   - 4~14줄의 주석에서 문제를 이해하고 접근하는 과정이 드러남
   - "음 이전 집에서 현재와 다른 색상을 칠하는 경우의 최소값을 구하는 것임" - 핵심을 정확히 파악

4. **깔끔한 함수 시그니처**
   - docstring으로 파라미터와 반환값 명시
   - 타입 힌트 사용 (`n: int, costs: list[list[int]]`)

## 다른 응용 방안

1. **타일 채우기 문제**
   - 2×N 타일 채우기 (1×2, 2×1 타일)
   - 각 열의 상태를 기준으로 DP

2. **원형 배열 변형 (도둑질 문제)**
   - 첫 번째와 마지막이 인접하는 경우
   - 케이스 분리: (첫 번째 포함, 마지막 제외) vs (첫 번째 제외, 마지막 포함)

3. **K가지 선택지 일반화**
   - 3색이 아닌 K색인 경우
   - 점화식: `dp[i][c] = min(dp[i-1][c']: c' != c) + cost[i][c]`
   - O(NK) → O(N) 최적화 가능 (최솟값, 차순위 최솟값 추적)

4. **2D 그리드 색칠**
   - 체스판 색칠, 지도 색칠 문제
   - 비트마스크 DP로 확장

## 추천 문제

| 문제 | 플랫폼 | 난이도 | 학습 포인트 |
|------|--------|--------|-------------|
| **도둑질** | 프로그래머스 Lv.4 | 중 | 원형 배열 DP, 케이스 분리 |
| **RGB거리 2** | 백준 17404 | 중 | 원형 조건 추가된 확장판 |
| **스티커** | 백준 9465 | 하 | 2×N 그리드 DP |
| **포도주 시식** | 백준 2156 | 하 | 연속 선택 제한 DP |
| **정수 삼각형** | 프로그래머스 Lv.3 | 하 | 2D 그리드 DP 기초 |

## 종합 평가

분석 문서를 보고 구현한 것을 솔직히 밝혀주셔서 좋습니다. **분석 → 구현** 흐름은 DP 학습의 정석적인 방법이며, 이번 풀이에서 그 과정을 잘 수행했습니다.

코드 자체는 군더더기 없이 깔끔합니다. 특히 **공간 최적화를 바로 적용**한 점이 좋습니다. 많은 초보자들이 2D 배열 전체를 유지하는데, `prev`/`curr` 패턴을 바로 적용한 것은 분석 문서의 인사이트를 제대로 흡수했음을 보여줍니다.

다만, 이 문제는 DP 중에서도 **가장 기초적인 패턴**입니다. 이 패턴을 완전히 체화했다면, 다음 단계로 **원형 배열 변형(RGB거리 2, 도둑질)**이나 **K가지 선택지 일반화** 문제에 도전해보세요. 특히 도둑질 문제는 이미 폴더가 있으니, 이 문제와의 차이점을 비교해보면 학습 효과가 높을 것입니다.

**다음 학습 방향**: 분석 문서 없이 직접 점화식 도출 → 구현까지 해보기
