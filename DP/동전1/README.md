# 동전 1

#DP #배낭문제 #UnboundedKnapsack #경우의수 #코딩테스트

---

## 0. 한 줄 핵심

> **동전을 무한히 쓸 수 있는 Unbounded Knapsack — 정순 순회로 경우의 수를 O(NK)에 센다.**

---

## 1. 시그널 탐지

### 키워드 → 알고리즘 매핑

| 지문 키워드/표현 | 연상되는 알고리즘/자료구조 |
|---|---|
| "n가지 종류의 동전", "합이 k원" | 배낭 문제 (Knapsack DP) |
| "경우의 수를 구하시오" | 카운팅 DP (최적화가 아닌 경우의 수 세기) |
| "각각의 동전은 몇 개라도 사용할 수 있다" | **Unbounded** Knapsack (0/1이 아님) |
| "순서만 다른 것은 같은 경우" | 동전(물건) 단위로 순회해야 중복 조합 방지 |

### 제약 조건 역산

- n = 1 ~ 100 (동전 종류 수)
- k = 1 ~ 10,000 (목표 금액)
- 시간 제한: 0.5초 → 약 5 × 10^7 연산 가능
- n × k = 100 × 10,000 = **10^6** → 충분히 여유
- 메모리 제한: 4MB → 1D 배열 필수 (2D 배열 시 100 × 10,001 × 4bytes ≈ 4MB로 아슬아슬)
- **허용 복잡도**: O(NK) 이하

---

## 2. 개념 리마인드

**핵심 개념**

Unbounded Knapsack의 카운팅 변형이다. 각 동전을 무한히 사용할 수 있으므로,
`dp[j] = 금액 j를 만드는 경우의 수`로 정의하면
점화식은 `dp[j] += dp[j - coin]` (j >= coin)이 된다.
**정순 순회**(coin → k)를 사용하면 같은 동전을 여러 번 사용하는 효과가 자연스럽게 생기고,
**동전 단위 외부 루프**를 돌면 순서가 다른 중복 카운팅(예: 1+2와 2+1)을 방지한다.

**스켈레톤 참조**: [`_learning/다이나믹 프로그래밍/skeleton.md`](../../_learning/다이나믹%20프로그래밍/skeleton.md)

### 점화식 `dp[j] += dp[j - coin]`이 의미하는 것

이 점화식은 이런 질문을 하는 것이다:

> **"금액 j를 만들 때, 이 동전(coin)을 마지막에 하나 쓸 수 있는가?"**

쓸 수 있다면, **coin을 하나 빼고 남은 금액 `j - coin`을 만드는 방법의 수**만큼 경우가 추가된다.

```
dp[j] = dp[j] + dp[j - coin]
        ─────   ─────────────
          ①           ②
```

- **①** `dp[j]` (기존): 이 동전을 **안 쓰고** j원을 만드는 경우의 수 (이전 동전들로만 만든 결과)
- **②** `dp[j - coin]`: 이 동전을 **하나 쓰기로 결정**하면, 나머지 `j - coin`원을 만드는 방법이 몇 가지인지

즉 **"이 동전을 안 쓰는 경우" + "이 동전을 쓰는 경우"** = 전체 경우의 수다.

**구체적 예시**: 동전 = `[1, 2]`, coin=2를 처리하며 dp[7]을 갱신하는 시점

```
dp[7] = dp[7] + dp[7 - 2]
        ─────   ─────────
          ①         ②

①: 2원 동전을 안 쓰고 7원을 만드는 경우의 수 (1원짜리만으로 만든 결과)
②: 2원 동전을 하나 쓰기로 결정 → 나머지 5원을 만드는 방법이 몇 가지?
```

**더 작은 예시로 확인**: 동전 = `[1, 2]`, k = 4

coin=1 처리 후 (1원짜리만으로):

```
dp = [1, 1, 1, 1, 1]
      0  1  2  3  4    ← 각각 1가지씩 (1원만 나열)
```

coin=2 처리 — j=2부터 하나씩:

```
j=2: dp[2] = dp[2] + dp[0] = 1 + 1 = 2
             ─────   ─────
             {1,1}    {2}       ← 2원 안 쓰기 1가지 + 2원 쓰기 1가지

j=3: dp[3] = dp[3] + dp[1] = 1 + 1 = 2
             ─────   ─────
            {1,1,1}  {2,1}     ← 2원 안 쓰기 1가지 + 2원 쓰고 남은 1원 만들기 1가지

j=4: dp[4] = dp[4] + dp[2] = 1 + 2 = 3
             ─────   ─────
           {1,1,1,1} {2,1,1}   ← 2원 안 쓰기 1가지 + 2원 쓰고 남은 2원 만들기 2가지
                     {2,2}
```

dp[4] = 3 → {1111, 211, 22} — 정답!

**핵심 직관**: `dp[j] += dp[j - coin]`은 **"coin 하나를 꺼내 놓으면, 나머지를 채우는 방법이 몇 가지?"** 를 누적하는 것이다. 각 동전 종류마다 이 질문을 반복하면, 모든 조합이 빠짐없이 세어진다.

---

## 3. 알고리즘 선택 논증

**선택**: Unbounded Knapsack DP (Bottom-Up, 1D, 정순 순회)

**선택 근거**:
- 동전을 무한히 사용 가능 + 합이 k인 경우의 수 → 전형적인 Unbounded Knapsack 카운팅
- n × k = 10^6으로 0.5초 내 충분
- 메모리 4MB 제한이 빠듯하므로 1D 배열이 사실상 필수

### 기각된 대안

| 대안 알고리즘 | 기각 이유 |
|---|---|
| 완전탐색 (재귀) | 경우의 수가 기하급수적 → 시간 초과 |
| 2D DP (`dp[i][j]`) | 정답은 나오지만 메모리 4MB 제한에 걸릴 수 있음 |
| BFS/DFS 탐색 | 상태 공간이 너무 크고 DP의 중복 부분 문제 활용 불가 |
| 금액 단위 외부 루프 | 순서가 다른 조합을 별개로 세어 오답 (순열 카운팅이 됨) |

---

## 4. 단계별 풀이

### 알고리즘 흐름

1. **DP 배열 초기화** — 크기 k+1의 배열을 0으로 초기화하고, `dp[0] = 1`로 설정한다. 금액 0을 만드는 방법은 "아무 동전도 안 쓰기" 1가지이므로 `[Code: L05-L06]`
2. **동전별 순회 (외부 루프)** — 각 동전 coin에 대해 DP를 갱신한다. 동전 단위로 순회해야 {1+2}와 {2+1}을 같은 경우로 취급할 수 있으므로 `[Code: L09]`
3. **정순 금액 순회 (내부 루프)** — j를 coin부터 k까지 **정순으로** 순회한다. 정순이므로 `dp[j-coin]`에 이미 현재 동전이 반영된 값이 포함되어 있어 같은 동전의 재사용이 자연스럽게 허용되므로 `[Code: L11]`
4. **점화식 적용** — `dp[j] += dp[j - coin]`. 금액 j에서 coin 하나를 빼면 남은 금액 j-coin을 만드는 방법의 수만큼 경우가 추가되므로 `[Code: L12]`
5. **답 출력** — `dp[k]`가 최종 경우의 수이므로 `[Code: L14]`

### 예제 손추적

**입력**: `n=3, k=10`, 동전 = `[1, 2, 5]`

**coin=1 처리 후** (1원짜리만으로 만드는 경우):

| dp[0] | dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

→ 1원짜리만으로 각 금액을 만드는 방법은 항상 1가지

**coin=2 처리 후** (1원, 2원을 조합):

| dp[0] | dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 2 | 2 | 3 | 3 | 4 | 4 | 5 | 5 | 6 |

→ 예: dp[4]=3 → {1111, 112, 22}

**coin=5 처리 후** (1원, 2원, 5원 모두 조합):

| dp[0] | dp[1] | dp[2] | dp[3] | dp[4] | dp[5] | dp[6] | dp[7] | dp[8] | dp[9] | dp[10] |
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 2 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | **10** |

→ dp[5]: 기존 3 + dp[0]=1 → 4 (5원 동전 1개 사용하는 경우 추가)
→ dp[10]: 기존 6 + dp[5]=4 → **10**

**출력**: `10`

---

## 5. 코드 구현

```python
import sys
input = sys.stdin.readline

def solve():
    # [Step 1] 입력 및 DP 초기화
    n, k = map(int, input().split())
    coins = [int(input()) for _ in range(n)]

    dp = [0] * (k + 1)
    dp[0] = 1  # 금액 0을 만드는 방법: 아무것도 안 쓰기 1가지

    # [Step 2] 동전별 순회 — 조합(순서 무시) 카운팅을 위해 동전이 외부 루프
    for coin in coins:
        # [Step 3] 정순 순회 — 같은 동전 재사용 허용 (Unbounded)
        for j in range(coin, k + 1):
            # [Step 4] 점화식 — coin을 하나 쓰고 남은 금액의 경우의 수를 더함
            dp[j] += dp[j - coin]

    # [Step 5] 답 출력
    print(dp[k])

solve()
```

**복잡도**
- 시간: O(NK) = O(100 × 10,000) = O(10^6) — 각 동전에 대해 금액 coin~k를 순회
- 공간: O(K) = O(10,000) — 1D 배열만 사용

---

## 6. 함정과 오답 분석

### 왜 동전이 외부 루프인가? — 조합 vs 순열

루프 순서에 따라 세는 것이 완전히 달라진다.

**동전이 외부 루프 (현재 풀이) → 조합 카운팅**

```
for coin in coins:       ← 동전 종류별로 "이 동전을 쓸지 말지" 결정
    for j in range(coin, k+1):
```

동전 1을 **모두 처리한 뒤** 동전 2를 처리한다. 따라서 {1, 2}와 {2, 1}은 같은 경우로 1번만 세어진다.

**금액이 외부 루프 → 순열 카운팅 (오답)**

```
for j in range(1, k+1):       ← 각 금액에서 모든 동전을 시도
    for coin in coins:
```

금액 3에서: dp[3] += dp[2] (1원 사용) + dp[1] (2원 사용)
→ dp[2]에는 이미 {1,1}과 {2}가 포함되어 있으므로 {1,1,1}과 {2,1}이 생김
→ dp[1]에서 {1}이 있으므로 {1,2}가 생김
→ {2,1}과 {1,2}를 별개로 센다 = **순열**

### 함정 테이블

| 함정 | 증상 | 해결 |
|---|---|---|
| 루프 순서 뒤바뀜 (금액이 외부) | 경우의 수가 과다 (순열 카운팅) | **동전이 외부 루프**, 금액이 내부 루프 |
| dp[0] 초기화 누락 | 모든 dp 값이 0으로 유지 | `dp[0] = 1` (빈 조합 1가지) |
| 역순 순회 사용 | 각 동전을 1번만 쓸 수 있게 됨 (0/1 Knapsack) | **정순 순회**로 무한 사용 허용 |
| 메모리 초과 (2D DP) | 4MB 제한에 걸림 | 1D 배열로 공간 최적화 |

### 반례 시나리오

- **입력**: `n=2, k=4`, 동전 = `[1, 2]`
- **기대 출력**: `3` ({1111, 112, 22})
- **오답 출력 (루프 순서 뒤바뀜)**: `5` ({1111, 112, 121, 211, 22}) — 순열로 카운팅됨

- **입력**: `n=1, k=0`, 동전 = `[1]`
- **기대 출력**: `1` (아무것도 안 쓰기)
- **오답 출력 (dp[0]=0)**: `0` — 초기값 실수

---

## 7. 다른 풀이

### 대안 풀이 A: 2D DP 테이블

`dp[i][j] = i번째 동전까지 사용하여 금액 j를 만드는 경우의 수`로 명시적 2D 테이블 관리.
직관적이지만 이 문제는 메모리 4MB 제한으로 위험하다.

```python
dp = [[0] * (k + 1) for _ in range(n + 1)]
dp[0][0] = 1
for i in range(1, n + 1):
    for j in range(k + 1):
        dp[i][j] = dp[i-1][j]  # 이 동전 안 쓰는 경우
        if j >= coins[i-1]:
            dp[i][j] += dp[i][j - coins[i-1]]  # 이 동전 또 쓰는 경우 (dp[i] 참조!)
```

### 대안 풀이 B: Top-Down 메모이제이션

`f(i, j) = i번째 동전부터 사용하여 금액 j를 만드는 경우의 수`로 재귀 정의.
상태가 희소할 때 유리하지만, 이 문제는 대부분의 상태를 방문하므로 이점이 적다.

**트레이드오프**:

| 비교 항목 | 현재 풀이 (1D Bottom-Up) | 2D Bottom-Up | Top-Down |
|---|---|---|---|
| 시간 복잡도 | O(NK) | O(NK) | O(NK) |
| 공간 복잡도 | **O(K)** | O(NK) | O(NK) + 재귀 스택 |
| 메모리 4MB 통과 | 안전 | 위험 | 위험 |
| 구현 난이도 | 중 (루프 순서 이해 필요) | 하 (직관적) | 중 |

**선호 시점**:
- **2D Bottom-Up**: DP 학습 초기, 디버깅이 필요할 때 (메모리 여유가 있는 문제에서)
- **Top-Down**: 상태 공간이 희소하거나 가지치기가 효과적인 변형
- **1D Bottom-Up**: 메모리 제한이 빠듯하거나 (이 문제), 실전에서 간결한 코드가 필요할 때

---

## 8. 패턴 카드 & 유사 문제

### 패턴 카드

```
📌 패턴명: Unbounded Knapsack 카운팅 (동전 교환)
🎯 트리거: "동전 무한 사용" + "경우의 수" + "순서 무관"
🧩 핵심:   dp[j] += dp[j-coin], 동전이 외부 루프 + 정순 순회
⚠️ 주의:   루프 순서 뒤바뀌면 순열 카운팅, 역순 순회하면 0/1 Knapsack
🔗 스켈레톤: _learning/다이나믹 프로그래밍/skeleton.md
```

### 유사 문제

| 난이도 | 문제 | 포인트 |
|---|---|---|
| ⭐ 입문 | 백준 2294 동전 2 | 같은 동전 설정이지만 "최소 개수" 구하기 — min DP로 전환 |
| ⭐ 입문 | 프로그래머스 거스름돈 | 동일 구조의 경우의 수 문제, 나머지 연산 주의 |
| ⭐⭐ 연습 | 백준 12865 평범한 배낭 | 0/1 Knapsack — 역순 순회와 비교하며 차이점 체감 |
| ⭐⭐ 연습 | 백준 9084 동전 | 여러 테스트케이스 처리 + 동일 로직 |
| ⭐⭐⭐ 실전 | 백준 2629 양팔저울 | bool 배열 배낭 — 가능/불가능 판정형 변형 |
