# CoTe: 코딩 테스트 문제 풀이 저장소

매일 코딩 테스트 문제를 풀고 학습 과정을 기록하는 저장소입니다.

## 어려울 때 마다 보기

- 하나의 문제를 여러개의 논리적인 분석, 사고 단계로 나누어서 접근하자.
    - 

- 문제를 푸는 과정을 게속해서 기록하자.
    - 내가 어디까지 문제 풀이 과정을 생각했고, 왜 그 이상으로 넘어가지 못했는지 파악할 수 있도록 기록해야 한다.
    - 문제를 보고 어떤 알고리즘을 사용하려 했는지, 그 근거와 과정을 코드로 어떻게 구현하려 했는지를 기록해야 한다.

- 시험 치듯이 공부하자.
    - 실제 시험 시간 처럼 제한된 시간내에  생각하고 테스트 케이스를 만들고, 구현하고 해결하자.

- 이해할 때 까지 게속하자.
    - 문제를 이해 하지 못했다면, 자료 조사를 하고 AI에게 물어보고, 왜 내가 이해하지 못했는지 등을 문서로 보관한다.
    - 필요에 따라서는 글 뿐만 아니라 시각적인 텍스트, 이미지로 기록한다.

## 고민 없이 풀는 방법은 없을까?

- [변수 및 함수 작명법](NAMING.md)
- [문제 풀이 방법](SOLVING.md)
- [이진 트리 자료구조](_learning/이진_트리.md)
- [입력 크기에 따른 알고리즘 선택](_learning/입력_크기에_따른_알고리즘_선택.md)

## CoTe 핵심 가치: 감으로 풀지 않고, 절차로 푼다

코테도 고등학교 수학처럼 **문제풀이 절차**가 있어야 합니다.

고정 루틴:
**문제 읽기 → 유형 판별 → 풀이 틀 선택 → 검증 → 구현**

정답은 운으로 맞출 수 있어도, 실력은 루틴으로만 쌓입니다.

### 처음 보는 문제 표준 절차 (실전용)

1. **문제 번역 (2~3분)**
   - 입력/출력 한 줄 요약
   - 제약 확인 (N, 시간/메모리 제한)
   - 정답이 만족해야 할 조건 정의

2. **유형 판별 (1분)**
   - 연속 구간 최적화 → 슬라이딩 윈도우
   - 빠른 존재 확인/빈도 → 해시
   - 최소/최대 + 정렬 가능 → 그리디 검토
   - 최단거리/연결성 → 그래프(BFS/DFS/Dijkstra)
   - 경우의 수/최적 부분구조 → DP
   - 정답 범위 탐색 → 이분탐색(파라메트릭)

3. **풀이 틀 선택 (3분)**
   - 브루트포스 먼저 작성(사고용)
   - 왜 안 되는지 복잡도로 컷
   - 알고리즘 후보 2개 비교 후 1개 선택 + 근거 기록

4. **정당성 체크 (2분)**
   - 핵심 불변식 1~2개
   - 엣지 케이스 3개: 최소 입력 / 중복·동일값 / 최대 N

5. **구현 (10~20분)**
   - 뼈대 먼저 작성
   - 손추적 테스트 2~3개
   - 시간/공간 복잡도 최종 확인

### 유형별 학습 원칙 (5문제 루프)

유형당 아래 5문제로 뼈대를 고정합니다.

- 대표문제 1개 (교과서)
- 변형문제 2개 (조건 1개씩 변경)
- 함정문제 1개 (반례 중심)
- 복기문제 1개 (3일 뒤 재풀이)

### 고등수학식 5줄 노트

문제마다 아래 5줄을 기록합니다.

- 유형
- 핵심 아이디어
- 정답 근거(불변식)
- 자주 틀리는 포인트
- 재풀이 트리거 문장

예)
- 유형: 투포인터
- 트리거: 정렬된 배열에서 합/차 조건을 만족하는 쌍 찾기

### 우리가 키우는 능력

처음 보는 문제를 푸는 힘 =
처음 보는 문장을 익숙한 유형으로 변환하는 능력

그래서 목표는 정답 개수보다:
- 1분 안에 유형 후보 2개로 좁히기
- 복잡도로 틀린 방법 빠르게 버리기

### 유형별 공식 암기 학습법

코테는 문제 자체를 외우는 게 아니라,
**유형별 풀이 공식(패턴)을 암기하고 적용**하는 훈련으로 접근합니다.

#### 알고리즘마다 암기할 4가지
- **트리거 문장**: 어떤 문장을 보면 이 유형을 의심할지
- **핵심 불변식**: 왜 이 풀이가 정답이 되는지
- **템플릿 코드**: 15~30줄 기본 뼈대
- **실수 포인트**: 경계값/초기화/중복 처리 등 자주 틀리는 부분

#### 하루 루틴 (공식 암기 + 적용)
- 10분: 오늘 유형 트리거/불변식/템플릿 암기
- 30~40분: 대표 1문제 + 변형 1문제 적용
- 10분: 문제당 5줄 노트 정리
- 5분: 템플릿 백지 재작성

#### 복습 루프 (망각 방지)
- Day 0: 처음 학습
- Day 1: 템플릿 재작성 + 1문제
- Day 3: 복기문제 재풀이
- Day 7: 함정문제 재풀이

### 필수 암기 템플릿 위치

필수 암기 템플릿은 `_learning` 폴더에서 관리합니다.

- `_learning/BFS/skeleton.md`
- `_learning/DFS/skeleton.md`
- `_learning/다익스트라/skeleton.md`
- `_learning/다이나믹 프로그래밍/skeleton.md`
- `_learning/완전탐색/skeleton.md`
- `_learning/구현_시뮬레이션/skeleton.md`
- `_learning/투포인터/skeleton.md`
- `_learning/슬라이딩윈도우/skeleton.md`
- `_learning/이분탐색/skeleton.md`
- `_learning/해시/skeleton.md`

필요하면 위 템플릿을 기준으로 문제 유형별 체크리스트를 계속 확장합니다.

## 학습 목표

- 다양한 알고리즘과 자료구조 이해 및 습득
- 문제 해결 능력 및 사고 과정 정리
- 시간과 공간 복잡도 분석 능력 개발
- 꾸준한 학습과 성장 기록

## 사용 방법

### 1. 새 문제 폴더 생성
```bash
# 템플릿 폴더 복사 (번호_주제_문제명으로 이름 변경)
cp -r _template_programmers 001_해시_두개뽑아서더하기
cd 001_해시_두개뽑아서더하기
```

### 2. 테스트 케이스 작성
```python
# test.py에서 test_cases 배열을 채우기
test_cases = [
    # 여러 매개변수: 튜플 사용
    {"name": "...", "input": (1, 2, 3), "expected": 6},

    # 단일 매개변수: 리스트/문자열/숫자 등
    {"name": "...", "input": [1, 2, 3], "expected": [1, 2, 3]},
]

# 규칙: 튜플 = 언팩(여러 인자), 그 외 = 단일 인자
```

### 3. 로컬 테스트
```bash
# test.py 실행 (테스트 케이스 정의한 후)
python3 test.py

# 출력: 통과/실패, 시간, 메모리 측정
# test.py가 solution.py의 함수를 run_tests에 전달하여 실행
```

**다른 구현으로 테스트 (선택)**:
```python
# test.py에 추가로 작성
def my_solution(nums):
    return sorted(nums)

run_tests(my_solution, test_cases)  # 다른 구현 테스트
```

### 4. 풀이 작성
- `README.md`: 문제명, 해시태그, 풀이 과정, 회고 작성
- `solution.py`: 순수 풀이 코드만 작성 (프로그래머스 제출용)

### 5. 프로그래머스 제출
- `solution.py`의 `solution` 함수 코드를 프로그래머스에 복사해서 제출

### 6. 커밋
```bash
# 완료 후 메인 README.md 테이블에 추가하고 커밋
git add .
git commit -m "add(001_해시) : 두개뽑아서더하기 문제 풀이"
```

## 학습 통계

- 총 풀이 문제 수: 0
- 평균 풀이 시간: -
- 가장 자주 사용한 알고리즘: -

---

각 문제별 상세한 풀이 과정은 해당 폴더의 README.md를 참고하세요.
